// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_atlas_FlxAtlas
#include <flixel/graphics/atlas/FlxAtlas.h>
#endif
#ifndef INCLUDED_flixel_graphics_atlas_FlxNode
#include <flixel/graphics/atlas/FlxNode.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxTileFrames
#include <flixel/graphics/frames/FlxTileFrames.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_FlxAssets
#include <flixel/system/FlxAssets.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal1
#include <flixel/util/_FlxSignal/FlxSignal1.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f38becfab6571882_25_new,"flixel.graphics.atlas.FlxAtlas","new",0xc05046bf,"flixel.graphics.atlas.FlxAtlas.new","flixel/graphics/atlas/FlxAtlas.hx",25,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_153_initRoot,"flixel.graphics.atlas.FlxAtlas","initRoot",0x37652e93,"flixel.graphics.atlas.FlxAtlas.initRoot","flixel/graphics/atlas/FlxAtlas.hx",153,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_176_addNode,"flixel.graphics.atlas.FlxAtlas","addNode",0xeec7dea2,"flixel.graphics.atlas.FlxAtlas.addNode","flixel/graphics/atlas/FlxAtlas.hx",176,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_218_wrapRoot,"flixel.graphics.atlas.FlxAtlas","wrapRoot",0x7e08124d,"flixel.graphics.atlas.FlxAtlas.wrapRoot","flixel/graphics/atlas/FlxAtlas.hx",218,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_225_tryInsert,"flixel.graphics.atlas.FlxAtlas","tryInsert",0xc0214673,"flixel.graphics.atlas.FlxAtlas.tryInsert","flixel/graphics/atlas/FlxAtlas.hx",225,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_261_needToDivideHorizontally,"flixel.graphics.atlas.FlxAtlas","needToDivideHorizontally",0x28a8e09c,"flixel.graphics.atlas.FlxAtlas.needToDivideHorizontally","flixel/graphics/atlas/FlxAtlas.hx",261,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_270_divideNode,"flixel.graphics.atlas.FlxAtlas","divideNode",0x568bb99c,"flixel.graphics.atlas.FlxAtlas.divideNode","flixel/graphics/atlas/FlxAtlas.hx",270,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_356_insertFirstNodeInRoot,"flixel.graphics.atlas.FlxAtlas","insertFirstNodeInRoot",0xea82177f,"flixel.graphics.atlas.FlxAtlas.insertFirstNodeInRoot","flixel/graphics/atlas/FlxAtlas.hx",356,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_401_expand,"flixel.graphics.atlas.FlxAtlas","expand",0x67ef7d5b,"flixel.graphics.atlas.FlxAtlas.expand","flixel/graphics/atlas/FlxAtlas.hx",401,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_557_expandRoot,"flixel.graphics.atlas.FlxAtlas","expandRoot",0x3df0e11d,"flixel.graphics.atlas.FlxAtlas.expandRoot","flixel/graphics/atlas/FlxAtlas.hx",557,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_570_expandBitmapData,"flixel.graphics.atlas.FlxAtlas","expandBitmapData",0xdc8f96f4,"flixel.graphics.atlas.FlxAtlas.expandBitmapData","flixel/graphics/atlas/FlxAtlas.hx",570,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_588_getNextPowerOfTwo,"flixel.graphics.atlas.FlxAtlas","getNextPowerOfTwo",0x3bc20318,"flixel.graphics.atlas.FlxAtlas.getNextPowerOfTwo","flixel/graphics/atlas/FlxAtlas.hx",588,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_613_addNodeWithSpacesAndBorders,"flixel.graphics.atlas.FlxAtlas","addNodeWithSpacesAndBorders",0x375b9d25,"flixel.graphics.atlas.FlxAtlas.addNodeWithSpacesAndBorders","flixel/graphics/atlas/FlxAtlas.hx",613,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_666_getAtlasFrames,"flixel.graphics.atlas.FlxAtlas","getAtlasFrames",0xe2ec465c,"flixel.graphics.atlas.FlxAtlas.getAtlasFrames","flixel/graphics/atlas/FlxAtlas.hx",666,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_682_addNodeToAtlasFrames,"flixel.graphics.atlas.FlxAtlas","addNodeToAtlasFrames",0x19696d94,"flixel.graphics.atlas.FlxAtlas.addNodeToAtlasFrames","flixel/graphics/atlas/FlxAtlas.hx",682,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_708_hasNodeWithName,"flixel.graphics.atlas.FlxAtlas","hasNodeWithName",0x3a185aec,"flixel.graphics.atlas.FlxAtlas.hasNodeWithName","flixel/graphics/atlas/FlxAtlas.hx",708,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_719_getNode,"flixel.graphics.atlas.FlxAtlas","getNode",0x850d4b97,"flixel.graphics.atlas.FlxAtlas.getNode","flixel/graphics/atlas/FlxAtlas.hx",719,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_731_addNodes,"flixel.graphics.atlas.FlxAtlas","addNodes",0x001aef91,"flixel.graphics.atlas.FlxAtlas.addNodes","flixel/graphics/atlas/FlxAtlas.hx",731,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_754_addFromAtlasObjects,"flixel.graphics.atlas.FlxAtlas","addFromAtlasObjects",0xc364fff3,"flixel.graphics.atlas.FlxAtlas.addFromAtlasObjects","flixel/graphics/atlas/FlxAtlas.hx",754,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_768_bitmapSorter,"flixel.graphics.atlas.FlxAtlas","bitmapSorter",0x4abe7a5b,"flixel.graphics.atlas.FlxAtlas.bitmapSorter","flixel/graphics/atlas/FlxAtlas.hx",768,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_790_createQueue,"flixel.graphics.atlas.FlxAtlas","createQueue",0x315e3254,"flixel.graphics.atlas.FlxAtlas.createQueue","flixel/graphics/atlas/FlxAtlas.hx",790,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_802_addToQueue,"flixel.graphics.atlas.FlxAtlas","addToQueue",0x83cfa976,"flixel.graphics.atlas.FlxAtlas.addToQueue","flixel/graphics/atlas/FlxAtlas.hx",802,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_814_generateFromQueue,"flixel.graphics.atlas.FlxAtlas","generateFromQueue",0x8e4a2871,"flixel.graphics.atlas.FlxAtlas.generateFromQueue","flixel/graphics/atlas/FlxAtlas.hx",814,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_823_onClear,"flixel.graphics.atlas.FlxAtlas","onClear",0x4819a1cd,"flixel.graphics.atlas.FlxAtlas.onClear","flixel/graphics/atlas/FlxAtlas.hx",823,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_832_destroy,"flixel.graphics.atlas.FlxAtlas","destroy",0x8e06bed9,"flixel.graphics.atlas.FlxAtlas.destroy","flixel/graphics/atlas/FlxAtlas.hx",832,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_850_clear,"flixel.graphics.atlas.FlxAtlas","clear",0x59297dac,"flixel.graphics.atlas.FlxAtlas.clear","flixel/graphics/atlas/FlxAtlas.hx",850,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_863_getLibGdxData,"flixel.graphics.atlas.FlxAtlas","getLibGdxData",0x1a9c9615,"flixel.graphics.atlas.FlxAtlas.getLibGdxData","flixel/graphics/atlas/FlxAtlas.hx",863,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_896_deleteSubtree,"flixel.graphics.atlas.FlxAtlas","deleteSubtree",0xf9ad5912,"flixel.graphics.atlas.FlxAtlas.deleteSubtree","flixel/graphics/atlas/FlxAtlas.hx",896,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_906_findNodeToInsert,"flixel.graphics.atlas.FlxAtlas","findNodeToInsert",0x513a4b50,"flixel.graphics.atlas.FlxAtlas.findNodeToInsert","flixel/graphics/atlas/FlxAtlas.hx",906,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_972_set_bitmapData,"flixel.graphics.atlas.FlxAtlas","set_bitmapData",0xf5eb1e77,"flixel.graphics.atlas.FlxAtlas.set_bitmapData","flixel/graphics/atlas/FlxAtlas.hx",972,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_981_get_graphic,"flixel.graphics.atlas.FlxAtlas","get_graphic",0xa3fa281e,"flixel.graphics.atlas.FlxAtlas.get_graphic","flixel/graphics/atlas/FlxAtlas.hx",981,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_992_set_persist,"flixel.graphics.atlas.FlxAtlas","set_persist",0xbdd0f696,"flixel.graphics.atlas.FlxAtlas.set_persist","flixel/graphics/atlas/FlxAtlas.hx",992,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1000_set_minWidth,"flixel.graphics.atlas.FlxAtlas","set_minWidth",0x9b144052,"flixel.graphics.atlas.FlxAtlas.set_minWidth","flixel/graphics/atlas/FlxAtlas.hx",1000,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1012_set_minHeight,"flixel.graphics.atlas.FlxAtlas","set_minHeight",0xccf3801b,"flixel.graphics.atlas.FlxAtlas.set_minHeight","flixel/graphics/atlas/FlxAtlas.hx",1012,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1024_get_width,"flixel.graphics.atlas.FlxAtlas","get_width",0x463c19fc,"flixel.graphics.atlas.FlxAtlas.get_width","flixel/graphics/atlas/FlxAtlas.hx",1024,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1032_set_width,"flixel.graphics.atlas.FlxAtlas","set_width",0x298d0608,"flixel.graphics.atlas.FlxAtlas.set_width","flixel/graphics/atlas/FlxAtlas.hx",1032,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1051_get_height,"flixel.graphics.atlas.FlxAtlas","get_height",0xe4aa1b31,"flixel.graphics.atlas.FlxAtlas.get_height","flixel/graphics/atlas/FlxAtlas.hx",1051,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1058_set_height,"flixel.graphics.atlas.FlxAtlas","set_height",0xe827b9a5,"flixel.graphics.atlas.FlxAtlas.set_height","flixel/graphics/atlas/FlxAtlas.hx",1058,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1077_set_maxWidth,"flixel.graphics.atlas.FlxAtlas","set_maxWidth",0x4dfa2600,"flixel.graphics.atlas.FlxAtlas.set_maxWidth","flixel/graphics/atlas/FlxAtlas.hx",1077,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1085_set_maxHeight,"flixel.graphics.atlas.FlxAtlas","set_maxHeight",0xa33692ad,"flixel.graphics.atlas.FlxAtlas.set_maxHeight","flixel/graphics/atlas/FlxAtlas.hx",1085,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_1093_set_powerOfTwo,"flixel.graphics.atlas.FlxAtlas","set_powerOfTwo",0xacd9272e,"flixel.graphics.atlas.FlxAtlas.set_powerOfTwo","flixel/graphics/atlas/FlxAtlas.hx",1093,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_27_boot,"flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",27,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_28_boot,"flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",28,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_33_boot,"flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",33,0x03972f50)
HX_LOCAL_STACK_FRAME(_hx_pos_f38becfab6571882_38_boot,"flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",38,0x03972f50)
namespace flixel{
namespace graphics{
namespace atlas{

void FlxAtlas_obj::__construct(::String name,hx::Null< bool >  __o_powerOfTwo,hx::Null< int >  __o_border,hx::Null< bool >  __o_rotate, ::flixel::math::FlxPoint minSize, ::flixel::math::FlxPoint maxSize){
bool powerOfTwo = __o_powerOfTwo.Default(false);
int border = __o_border.Default(1);
bool rotate = __o_rotate.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_25_new)
HXLINE( 111)		this->powerOfTwo = false;
HXLINE( 106)		this->allowRotation = false;
HXLINE( 101)		this->maxHeight = (int)1024;
HXLINE(  97)		this->maxWidth = (int)1024;
HXLINE(  92)		this->minHeight = (int)128;
HXLINE(  88)		this->minWidth = (int)128;
HXLINE(  71)		this->border = (int)1;
HXLINE(  66)		this->persist = false;
HXLINE( 133)		this->nodes =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 134)		this->name = name;
HXLINE( 135)		this->set_powerOfTwo(powerOfTwo);
HXLINE( 136)		this->border = border;
HXLINE( 138)		if (hx::IsNotNull( minSize )) {
HXLINE( 138)			minSize = minSize;
            		}
            		else {
HXLINE( 138)			minSize = ::flixel::graphics::atlas::FlxAtlas_obj::defaultMinSize;
            		}
HXLINE( 139)		if (hx::IsNotNull( maxSize )) {
HXLINE( 139)			maxSize = maxSize;
            		}
            		else {
HXLINE( 139)			maxSize = ::flixel::graphics::atlas::FlxAtlas_obj::defaultMaxSize;
            		}
HXLINE( 141)		this->set_minWidth(::Std_obj::_hx_int(minSize->x));
HXLINE( 142)		this->set_minHeight(::Std_obj::_hx_int(minSize->y));
HXLINE( 143)		int _hx_tmp;
HXDLIN( 143)		if ((maxSize->x > minSize->x)) {
HXLINE( 143)			_hx_tmp = ::Std_obj::_hx_int(maxSize->x);
            		}
            		else {
HXLINE( 143)			_hx_tmp = this->minWidth;
            		}
HXDLIN( 143)		this->set_maxWidth(_hx_tmp);
HXLINE( 144)		int _hx_tmp1;
HXDLIN( 144)		if ((maxSize->y > minSize->x)) {
HXLINE( 144)			_hx_tmp1 = ::Std_obj::_hx_int(maxSize->y);
            		}
            		else {
HXLINE( 144)			_hx_tmp1 = this->minHeight;
            		}
HXDLIN( 144)		this->set_maxHeight(_hx_tmp1);
HXLINE( 145)		this->allowRotation = rotate;
HXLINE( 147)		this->initRoot();
HXLINE( 149)		::flixel::FlxG_obj::signals->preStateCreate->add(this->onClear_dyn());
            	}

Dynamic FlxAtlas_obj::__CreateEmpty() { return new FlxAtlas_obj; }

void *FlxAtlas_obj::_hx_vtable = 0;

Dynamic FlxAtlas_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxAtlas_obj > _hx_result = new FlxAtlas_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

bool FlxAtlas_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x27a77bdd;
}

static ::flixel::util::IFlxDestroyable_obj _hx_flixel_graphics_atlas_FlxAtlas__hx_flixel_util_IFlxDestroyable= {
	( void (hx::Object::*)())&::flixel::graphics::atlas::FlxAtlas_obj::destroy,
};

void *FlxAtlas_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xd4fe2fcd: return &_hx_flixel_graphics_atlas_FlxAtlas__hx_flixel_util_IFlxDestroyable;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void FlxAtlas_obj::initRoot(){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_153_initRoot)
HXLINE( 154)		int rootWidth = this->minWidth;
HXLINE( 155)		int rootHeight = this->minHeight;
HXLINE( 157)		if (this->powerOfTwo) {
HXLINE( 159)			rootWidth = this->getNextPowerOfTwo(rootWidth);
HXLINE( 160)			rootHeight = this->getNextPowerOfTwo(rootHeight);
            		}
HXLINE( 163)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 163)		_this->x = (int)0;
HXDLIN( 163)		_this->y = (int)0;
HXDLIN( 163)		_this->width = rootWidth;
HXDLIN( 163)		_this->height = rootHeight;
HXDLIN( 163)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 163)		rect->_inPool = false;
HXDLIN( 163)		this->root =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,initRoot,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::addNode( ::Dynamic Graphic,::String Key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_176_addNode)
HXLINE( 177)		::String key = ::flixel::_hx_system::FlxAssets_obj::resolveKey(Graphic,Key);
HXLINE( 179)		if (hx::IsNull( key )) {
HXLINE( 182)			HX_STACK_DO_THROW(HX_("addNode can't find the key for specified BitmapData. Please provide not null value as a Key argument.",d2,94,28,ae));
            		}
HXLINE( 187)		if (this->hasNodeWithName(key)) {
HXLINE( 188)			return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            		}
HXLINE( 190)		 ::openfl::_legacy::display::BitmapData data = ::flixel::_hx_system::FlxAssets_obj::resolveBitmapData(Graphic);
HXLINE( 192)		if (hx::IsNull( data )) {
HXLINE( 195)			HX_STACK_DO_THROW(((HX_("addNode can't find BitmapData with specified key: ",7b,9b,ce,f1) + Graphic) + HX_(". Please provide valid value.",84,e6,88,32)));
            		}
HXLINE( 201)		if (hx::IsNull( this->root->left )) {
HXLINE( 202)			return this->insertFirstNodeInRoot(data,key);
            		}
HXLINE( 204)		if (hx::IsNull( this->root->right )) {
HXLINE( 205)			return this->expand(data,key);
            		}
HXLINE( 208)		 ::flixel::graphics::atlas::FlxNode inserted = this->tryInsert(data,key);
HXLINE( 209)		if (hx::IsNotNull( inserted )) {
HXLINE( 210)			return inserted;
            		}
HXLINE( 213)		this->wrapRoot();
HXLINE( 214)		return this->expand(data,key);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addNode,return )

void FlxAtlas_obj::wrapRoot(){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_218_wrapRoot)
HXLINE( 219)		 ::flixel::graphics::atlas::FlxNode temp = this->root;
HXLINE( 220)		Float Width = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 220)		Float Height = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 220)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 220)		_this->x = (int)0;
HXDLIN( 220)		_this->y = (int)0;
HXDLIN( 220)		_this->width = Width;
HXDLIN( 220)		_this->height = Height;
HXDLIN( 220)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 220)		rect->_inPool = false;
HXDLIN( 220)		this->root =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 221)		this->root->left = temp;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,wrapRoot,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::tryInsert( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_225_tryInsert)
HXLINE( 226)		int insertWidth = data->get_width();
HXDLIN( 226)		int insertWidth1 = (insertWidth + this->border);
HXLINE( 227)		int insertHeight = data->get_height();
HXDLIN( 227)		int insertHeight1 = (insertHeight + this->border);
HXLINE( 229)		bool rotateNode = false;
HXLINE( 230)		 ::flixel::graphics::atlas::FlxNode nodeToInsert = this->findNodeToInsert(insertWidth1,insertHeight1);
HXLINE( 232)		if (this->allowRotation) {
HXLINE( 234)			 ::flixel::graphics::atlas::FlxNode nodeToInsertWithRotation = this->findNodeToInsert(insertHeight1,insertWidth1);
HXLINE( 236)			if (hx::IsNotNull( nodeToInsertWithRotation )) {
HXLINE( 238)				int nodeWithRotationArea = ::Std_obj::_hx_int(nodeToInsertWithRotation->rect->width);
HXDLIN( 238)				int nodeWithRotationArea1 = (nodeWithRotationArea * ::Std_obj::_hx_int(nodeToInsertWithRotation->rect->height));
HXLINE( 240)				bool _hx_tmp;
HXDLIN( 240)				if (hx::IsNotNull( nodeToInsert )) {
HXLINE( 240)					if (hx::IsNotNull( nodeToInsert )) {
HXLINE( 240)						int _hx_tmp1 = ::Std_obj::_hx_int(nodeToInsert->rect->width);
HXDLIN( 240)						_hx_tmp = ((_hx_tmp1 * ::Std_obj::_hx_int(nodeToInsert->rect->height)) > nodeWithRotationArea1);
            					}
            					else {
HXLINE( 240)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE( 240)					_hx_tmp = true;
            				}
HXDLIN( 240)				if (_hx_tmp) {
HXLINE( 242)					nodeToInsert = nodeToInsertWithRotation;
HXLINE( 243)					rotateNode = true;
HXLINE( 244)					int temp = insertWidth1;
HXLINE( 245)					insertWidth1 = insertHeight1;
HXLINE( 246)					insertHeight1 = temp;
            				}
            			}
            		}
HXLINE( 251)		if (hx::IsNotNull( nodeToInsert )) {
HXLINE( 253)			bool horizontally = this->needToDivideHorizontally(nodeToInsert,insertWidth1,insertHeight1);
HXLINE( 254)			return this->divideNode(nodeToInsert,insertWidth1,insertHeight1,horizontally,data,key,rotateNode);
            		}
HXLINE( 257)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,tryInsert,return )

bool FlxAtlas_obj::needToDivideHorizontally( ::flixel::graphics::atlas::FlxNode nodeToDivide,int insertWidth,int insertHeight){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_261_needToDivideHorizontally)
HXLINE( 262)		int dw = (::Std_obj::_hx_int(nodeToDivide->rect->width) - insertWidth);
HXLINE( 263)		int dh = (::Std_obj::_hx_int(nodeToDivide->rect->height) - insertHeight);
HXLINE( 265)		return (dw > dh);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAtlas_obj,needToDivideHorizontally,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::divideNode( ::flixel::graphics::atlas::FlxNode nodeToDivide,int insertWidth,int insertHeight,bool divideHorizontally, ::openfl::_legacy::display::BitmapData firstGrandChildData,::String firstGrandChildKey,hx::Null< bool >  __o_firstGrandChildRotated){
bool firstGrandChildRotated = __o_firstGrandChildRotated.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_270_divideNode)
HXLINE( 271)		if (hx::IsNotNull( nodeToDivide )) {
HXLINE( 273)			 ::flixel::graphics::atlas::FlxNode firstChild = null();
HXLINE( 274)			 ::flixel::graphics::atlas::FlxNode secondChild = null();
HXLINE( 275)			 ::flixel::graphics::atlas::FlxNode firstGrandChild = null();
HXLINE( 276)			 ::flixel::graphics::atlas::FlxNode secondGrandChild = null();
HXLINE( 277)			bool firstGrandChildFilled = hx::IsNotNull( firstGrandChildKey );
HXLINE( 279)			if (divideHorizontally) {
HXLINE( 281)				Float X = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 281)				Float Y = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 281)				Float Height = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 281)				 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 281)				_this->x = X;
HXDLIN( 281)				_this->y = Y;
HXDLIN( 281)				_this->width = insertWidth;
HXDLIN( 281)				_this->height = Height;
HXDLIN( 281)				 ::flixel::math::FlxRect rect = _this;
HXDLIN( 281)				rect->_inPool = false;
HXDLIN( 281)				firstChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 284)				if (((::Std_obj::_hx_int(nodeToDivide->rect->width) - insertWidth) > (int)0)) {
HXLINE( 286)					Float X1 = (::Std_obj::_hx_int(nodeToDivide->rect->x) + insertWidth);
HXDLIN( 286)					Float Y1 = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 286)					Float Width = (::Std_obj::_hx_int(nodeToDivide->rect->width) - insertWidth);
HXDLIN( 286)					Float Height1 = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 286)					 ::flixel::math::FlxRect _this1 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 286)					_this1->x = X1;
HXDLIN( 286)					_this1->y = Y1;
HXDLIN( 286)					_this1->width = Width;
HXDLIN( 286)					_this1->height = Height1;
HXDLIN( 286)					 ::flixel::math::FlxRect rect1 = _this1;
HXDLIN( 286)					rect1->_inPool = false;
HXDLIN( 286)					secondChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect1,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
HXLINE( 290)				Float X2 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 290)				Float Y2 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 290)				 ::flixel::math::FlxRect _this2 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 290)				_this2->x = X2;
HXDLIN( 290)				_this2->y = Y2;
HXDLIN( 290)				_this2->width = insertWidth;
HXDLIN( 290)				_this2->height = insertHeight;
HXDLIN( 290)				 ::flixel::math::FlxRect rect2 = _this2;
HXDLIN( 290)				rect2->_inPool = false;
HXDLIN( 290)				firstGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect2,hx::ObjectPtr<OBJ_>(this),firstGrandChildFilled,firstGrandChildKey,firstGrandChildRotated);
HXLINE( 293)				if (((::Std_obj::_hx_int(firstChild->rect->height) - insertHeight) > (int)0)) {
HXLINE( 295)					Float X3 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 295)					Float Y3 = (::Std_obj::_hx_int(firstChild->rect->y) + insertHeight);
HXDLIN( 295)					Float Height2 = (::Std_obj::_hx_int(firstChild->rect->height) - insertHeight);
HXDLIN( 295)					 ::flixel::math::FlxRect _this3 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 295)					_this3->x = X3;
HXDLIN( 295)					_this3->y = Y3;
HXDLIN( 295)					_this3->width = insertWidth;
HXDLIN( 295)					_this3->height = Height2;
HXDLIN( 295)					 ::flixel::math::FlxRect rect3 = _this3;
HXDLIN( 295)					rect3->_inPool = false;
HXDLIN( 295)					secondGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect3,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
            			}
            			else {
HXLINE( 302)				Float X4 = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 302)				Float Y4 = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 302)				Float Width1 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 302)				 ::flixel::math::FlxRect _this4 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 302)				_this4->x = X4;
HXDLIN( 302)				_this4->y = Y4;
HXDLIN( 302)				_this4->width = Width1;
HXDLIN( 302)				_this4->height = insertHeight;
HXDLIN( 302)				 ::flixel::math::FlxRect rect4 = _this4;
HXDLIN( 302)				rect4->_inPool = false;
HXDLIN( 302)				firstChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect4,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 305)				if (((::Std_obj::_hx_int(nodeToDivide->rect->height) - insertHeight) > (int)0)) {
HXLINE( 307)					Float X5 = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 307)					Float Y5 = (::Std_obj::_hx_int(nodeToDivide->rect->y) + insertHeight);
HXDLIN( 307)					Float Width2 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 307)					Float Height3 = (::Std_obj::_hx_int(nodeToDivide->rect->height) - insertHeight);
HXDLIN( 307)					 ::flixel::math::FlxRect _this5 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 307)					_this5->x = X5;
HXDLIN( 307)					_this5->y = Y5;
HXDLIN( 307)					_this5->width = Width2;
HXDLIN( 307)					_this5->height = Height3;
HXDLIN( 307)					 ::flixel::math::FlxRect rect5 = _this5;
HXDLIN( 307)					rect5->_inPool = false;
HXDLIN( 307)					secondChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect5,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
HXLINE( 311)				Float X6 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 311)				Float Y6 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 311)				 ::flixel::math::FlxRect _this6 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 311)				_this6->x = X6;
HXDLIN( 311)				_this6->y = Y6;
HXDLIN( 311)				_this6->width = insertWidth;
HXDLIN( 311)				_this6->height = insertHeight;
HXDLIN( 311)				 ::flixel::math::FlxRect rect6 = _this6;
HXDLIN( 311)				rect6->_inPool = false;
HXDLIN( 311)				firstGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect6,hx::ObjectPtr<OBJ_>(this),firstGrandChildFilled,firstGrandChildKey,firstGrandChildRotated);
HXLINE( 314)				if (((::Std_obj::_hx_int(firstChild->rect->width) - insertWidth) > (int)0)) {
HXLINE( 316)					Float X7 = (::Std_obj::_hx_int(firstChild->rect->x) + insertWidth);
HXDLIN( 316)					Float Y7 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 316)					Float Width3 = (::Std_obj::_hx_int(firstChild->rect->width) - insertWidth);
HXDLIN( 316)					 ::flixel::math::FlxRect _this7 = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 316)					_this7->x = X7;
HXDLIN( 316)					_this7->y = Y7;
HXDLIN( 316)					_this7->width = Width3;
HXDLIN( 316)					_this7->height = insertHeight;
HXDLIN( 316)					 ::flixel::math::FlxRect rect7 = _this7;
HXDLIN( 316)					rect7->_inPool = false;
HXDLIN( 316)					secondGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect7,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
            			}
HXLINE( 321)			firstChild->left = firstGrandChild;
HXLINE( 322)			firstChild->right = secondGrandChild;
HXLINE( 324)			nodeToDivide->left = firstChild;
HXLINE( 325)			nodeToDivide->right = secondChild;
HXLINE( 328)			bool _hx_tmp;
HXDLIN( 328)			if (hx::IsNotNull( firstGrandChildKey )) {
HXLINE( 328)				_hx_tmp = hx::IsNotNull( firstGrandChildData );
            			}
            			else {
HXLINE( 328)				_hx_tmp = false;
            			}
HXDLIN( 328)			if (_hx_tmp) {
HXLINE( 330)				this->expandBitmapData();
HXLINE( 332)				if (firstGrandChildRotated) {
HXLINE( 334)					::flixel::graphics::atlas::FlxAtlas_obj::matrix->identity();
HXLINE( 335)					 ::openfl::_legacy::geom::Matrix _hx_tmp1 = ::flixel::graphics::atlas::FlxAtlas_obj::matrix;
HXDLIN( 335)					_hx_tmp1->rotate(((Float)::Math_obj::PI / (Float)(int)2));
HXLINE( 336)					 ::openfl::_legacy::geom::Matrix _hx_tmp2 = ::flixel::graphics::atlas::FlxAtlas_obj::matrix;
HXDLIN( 336)					int _hx_tmp3 = firstGrandChildData->get_height();
HXDLIN( 336)					int _hx_tmp4 = (_hx_tmp3 + ::Std_obj::_hx_int(firstGrandChild->rect->x));
HXDLIN( 336)					_hx_tmp2->translate(_hx_tmp4,::Std_obj::_hx_int(firstGrandChild->rect->y));
HXLINE( 337)					this->bitmapData->draw(firstGrandChildData,::flixel::graphics::atlas::FlxAtlas_obj::matrix,null(),null(),null(),null());
            				}
            				else {
HXLINE( 341)					 ::openfl::_legacy::geom::Point _hx_tmp5 = ::flixel::graphics::atlas::FlxAtlas_obj::point;
HXDLIN( 341)					int _hx_tmp6 = ::Std_obj::_hx_int(firstGrandChild->rect->x);
HXDLIN( 341)					_hx_tmp5->setTo(_hx_tmp6,::Std_obj::_hx_int(firstGrandChild->rect->y));
HXLINE( 342)					 ::openfl::_legacy::display::BitmapData _hx_tmp7 = this->bitmapData;
HXDLIN( 342)					 ::openfl::_legacy::geom::Rectangle _hx_tmp8 = firstGrandChildData->get_rect();
HXDLIN( 342)					_hx_tmp7->copyPixels(firstGrandChildData,_hx_tmp8,::flixel::graphics::atlas::FlxAtlas_obj::point,null(),null(),null());
            				}
HXLINE( 345)				this->addNodeToAtlasFrames(firstGrandChild);
HXLINE( 346)				this->nodes->set(firstGrandChildKey,firstGrandChild);
            			}
HXLINE( 349)			return firstGrandChild;
            		}
HXLINE( 352)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC7(FlxAtlas_obj,divideNode,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::insertFirstNodeInRoot( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_356_insertFirstNodeInRoot)
HXLINE( 357)		if (hx::IsNull( this->root->left )) {
HXLINE( 359)			int insertWidth = data->get_width();
HXDLIN( 359)			int insertWidth1 = (insertWidth + this->border);
HXLINE( 360)			int insertHeight = data->get_height();
HXDLIN( 360)			int insertHeight1 = (insertHeight + this->border);
HXLINE( 362)			int rootWidth = insertWidth1;
HXLINE( 363)			int rootHeight = insertHeight1;
HXLINE( 365)			if (this->powerOfTwo) {
HXLINE( 367)				rootWidth = this->getNextPowerOfTwo(rootWidth);
HXLINE( 368)				rootHeight = this->getNextPowerOfTwo(rootHeight);
            			}
HXLINE( 371)			if ((this->minWidth > rootWidth)) {
HXLINE( 371)				rootWidth = this->minWidth;
            			}
            			else {
HXLINE( 371)				rootWidth = rootWidth;
            			}
HXLINE( 372)			if ((this->minHeight > rootHeight)) {
HXLINE( 372)				rootHeight = this->minHeight;
            			}
            			else {
HXLINE( 372)				rootHeight = rootHeight;
            			}
HXLINE( 374)			if (this->powerOfTwo) {
HXLINE( 376)				rootWidth = this->getNextPowerOfTwo(rootWidth);
HXLINE( 377)				rootHeight = this->getNextPowerOfTwo(rootHeight);
            			}
HXLINE( 380)			bool _hx_tmp;
HXDLIN( 380)			bool _hx_tmp1;
HXDLIN( 380)			if ((this->maxWidth > (int)0)) {
HXLINE( 380)				_hx_tmp1 = (rootWidth > this->maxWidth);
            			}
            			else {
HXLINE( 380)				_hx_tmp1 = false;
            			}
HXDLIN( 380)			if (!(_hx_tmp1)) {
HXLINE( 380)				if ((this->maxHeight > (int)0)) {
HXLINE( 380)					_hx_tmp = (rootHeight > this->maxHeight);
            				}
            				else {
HXLINE( 380)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 380)				_hx_tmp = true;
            			}
HXDLIN( 380)			if (_hx_tmp) {
HXLINE( 383)				::String _hx_tmp2 = ((((HX_("Can't insert node ",5a,c7,4d,53) + key) + HX_(" with the size of (",b5,20,c2,55)) + data->get_width()) + HX_("; ",85,33,00,00));
HXDLIN( 383)				::String _hx_tmp3 = ((_hx_tmp2 + data->get_height()) + HX_(") in atlas ",99,70,14,d3));
HXDLIN( 383)				::String _hx_tmp4 = ((((((_hx_tmp3 + this->name) + HX_(" with the max size of (",b9,b3,66,74)) + this->maxWidth) + HX_("; ",85,33,00,00)) + this->maxHeight) + HX_(") and powerOfTwo: ",d6,69,4d,94));
HXDLIN( 383)				HX_STACK_DO_THROW((_hx_tmp4 + ::Std_obj::string(this->powerOfTwo)));
            			}
HXLINE( 390)			this->root->set_width(rootWidth);
HXLINE( 391)			this->root->set_height(rootHeight);
HXLINE( 393)			bool horizontally = this->needToDivideHorizontally(this->root,insertWidth1,insertHeight1);
HXLINE( 394)			return this->divideNode(this->root,insertWidth1,insertHeight1,horizontally,data,key,null());
            		}
HXLINE( 397)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,insertFirstNodeInRoot,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::expand( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_401_expand)
HXLINE( 402)		if (hx::IsNull( this->root->right )) {
HXLINE( 404)			int insertWidth = data->get_width();
HXDLIN( 404)			int insertWidth1 = (insertWidth + this->border);
HXLINE( 405)			int insertHeight = data->get_height();
HXDLIN( 405)			int insertHeight1 = (insertHeight + this->border);
HXLINE( 408)			int addRightWidth = (::Std_obj::_hx_int(this->root->rect->width) + insertWidth1);
HXLINE( 409)			int addRightHeight = ::Std_obj::_hx_int(::Math_obj::max(::Std_obj::_hx_int(this->root->rect->height),insertHeight1));
HXLINE( 411)			int addBottomWidth = ::Std_obj::_hx_int(::Math_obj::max(::Std_obj::_hx_int(this->root->rect->width),insertWidth1));
HXLINE( 412)			int addBottomHeight = (::Std_obj::_hx_int(this->root->rect->height) + insertHeight1);
HXLINE( 414)			int addRightWidthRotate = addRightWidth;
HXLINE( 415)			int addRightHeightRotate = addRightHeight;
HXLINE( 417)			int addBottomWidthRotate = addBottomWidth;
HXLINE( 418)			int addBottomHeightRotate = addBottomHeight;
HXLINE( 420)			if (this->allowRotation) {
HXLINE( 422)				addRightWidthRotate = (::Std_obj::_hx_int(this->root->rect->width) + insertHeight1);
HXLINE( 423)				addRightHeightRotate = ::Std_obj::_hx_int(::Math_obj::max(::Std_obj::_hx_int(this->root->rect->height),insertWidth1));
HXLINE( 425)				addBottomWidthRotate = ::Std_obj::_hx_int(::Math_obj::max(::Std_obj::_hx_int(this->root->rect->width),insertHeight1));
HXLINE( 426)				addBottomHeightRotate = (::Std_obj::_hx_int(this->root->rect->height) + insertWidth1);
            			}
HXLINE( 429)			if (this->powerOfTwo) {
HXLINE( 431)				addRightWidth = this->getNextPowerOfTwo(addRightWidth);
HXDLIN( 431)				addRightWidthRotate = addRightWidth;
HXLINE( 432)				addRightHeight = this->getNextPowerOfTwo(addRightHeight);
HXDLIN( 432)				addRightHeightRotate = addRightHeight;
HXLINE( 433)				addBottomWidth = this->getNextPowerOfTwo(addBottomWidth);
HXDLIN( 433)				addBottomWidthRotate = addBottomWidth;
HXLINE( 434)				addBottomHeight = this->getNextPowerOfTwo(addBottomHeight);
HXDLIN( 434)				addBottomHeightRotate = addBottomHeight;
HXLINE( 436)				if (this->allowRotation) {
HXLINE( 438)					addRightWidthRotate = this->getNextPowerOfTwo(addRightWidthRotate);
HXLINE( 439)					addRightHeightRotate = this->getNextPowerOfTwo(addRightHeightRotate);
HXLINE( 440)					addBottomWidthRotate = this->getNextPowerOfTwo(addBottomWidthRotate);
HXLINE( 441)					addBottomHeightRotate = this->getNextPowerOfTwo(addBottomHeightRotate);
            				}
            			}
HXLINE( 446)			bool canExpandRight = true;
HXLINE( 447)			bool canExpandBottom = true;
HXLINE( 449)			bool canExpandRightRotate = this->allowRotation;
HXLINE( 450)			bool canExpandBottomRotate = this->allowRotation;
HXLINE( 452)			bool _hx_tmp;
HXDLIN( 452)			bool _hx_tmp1;
HXDLIN( 452)			if ((this->maxWidth > (int)0)) {
HXLINE( 452)				_hx_tmp1 = (addRightWidth > this->maxWidth);
            			}
            			else {
HXLINE( 452)				_hx_tmp1 = false;
            			}
HXDLIN( 452)			if (!(_hx_tmp1)) {
HXLINE( 452)				if ((this->maxHeight > (int)0)) {
HXLINE( 452)					_hx_tmp = (addRightHeight > this->maxHeight);
            				}
            				else {
HXLINE( 452)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 452)				_hx_tmp = true;
            			}
HXDLIN( 452)			if (_hx_tmp) {
HXLINE( 453)				canExpandRight = false;
            			}
HXLINE( 455)			bool _hx_tmp2;
HXDLIN( 455)			bool _hx_tmp3;
HXDLIN( 455)			if ((this->maxWidth > (int)0)) {
HXLINE( 455)				_hx_tmp3 = (addBottomWidth > this->maxWidth);
            			}
            			else {
HXLINE( 455)				_hx_tmp3 = false;
            			}
HXDLIN( 455)			if (!(_hx_tmp3)) {
HXLINE( 455)				if ((this->maxHeight > (int)0)) {
HXLINE( 455)					_hx_tmp2 = (addBottomHeight > this->maxHeight);
            				}
            				else {
HXLINE( 455)					_hx_tmp2 = false;
            				}
            			}
            			else {
HXLINE( 455)				_hx_tmp2 = true;
            			}
HXDLIN( 455)			if (_hx_tmp2) {
HXLINE( 456)				canExpandBottom = false;
            			}
HXLINE( 458)			bool _hx_tmp4;
HXDLIN( 458)			bool _hx_tmp5;
HXDLIN( 458)			if ((this->maxWidth > (int)0)) {
HXLINE( 458)				_hx_tmp5 = (addRightWidthRotate > this->maxWidth);
            			}
            			else {
HXLINE( 458)				_hx_tmp5 = false;
            			}
HXDLIN( 458)			if (!(_hx_tmp5)) {
HXLINE( 458)				if ((this->maxHeight > (int)0)) {
HXLINE( 458)					_hx_tmp4 = (addRightHeightRotate > this->maxHeight);
            				}
            				else {
HXLINE( 458)					_hx_tmp4 = false;
            				}
            			}
            			else {
HXLINE( 458)				_hx_tmp4 = true;
            			}
HXDLIN( 458)			if (_hx_tmp4) {
HXLINE( 459)				canExpandRightRotate = false;
            			}
HXLINE( 461)			bool _hx_tmp6;
HXDLIN( 461)			bool _hx_tmp7;
HXDLIN( 461)			if ((this->maxWidth > (int)0)) {
HXLINE( 461)				_hx_tmp7 = (addBottomWidthRotate > this->maxWidth);
            			}
            			else {
HXLINE( 461)				_hx_tmp7 = false;
            			}
HXDLIN( 461)			if (!(_hx_tmp7)) {
HXLINE( 461)				if ((this->maxHeight > (int)0)) {
HXLINE( 461)					_hx_tmp6 = (addBottomHeightRotate > this->maxHeight);
            				}
            				else {
HXLINE( 461)					_hx_tmp6 = false;
            				}
            			}
            			else {
HXLINE( 461)				_hx_tmp6 = true;
            			}
HXDLIN( 461)			if (_hx_tmp6) {
HXLINE( 462)				canExpandBottomRotate = false;
            			}
HXLINE( 464)			bool _hx_tmp8;
HXDLIN( 464)			bool _hx_tmp9;
HXDLIN( 464)			bool _hx_tmp10;
HXDLIN( 464)			if (!(canExpandRight)) {
HXLINE( 464)				_hx_tmp10 = !(canExpandBottom);
            			}
            			else {
HXLINE( 464)				_hx_tmp10 = false;
            			}
HXDLIN( 464)			if (_hx_tmp10) {
HXLINE( 464)				_hx_tmp9 = !(canExpandRightRotate);
            			}
            			else {
HXLINE( 464)				_hx_tmp9 = false;
            			}
HXDLIN( 464)			if (_hx_tmp9) {
HXLINE( 464)				_hx_tmp8 = !(canExpandBottomRotate);
            			}
            			else {
HXLINE( 464)				_hx_tmp8 = false;
            			}
HXDLIN( 464)			if (_hx_tmp8) {
HXLINE( 467)				::String _hx_tmp11 = ((((HX_("Can't insert node ",5a,c7,4d,53) + key) + HX_(" with the size of (",b5,20,c2,55)) + data->get_width()) + HX_("; ",85,33,00,00));
HXDLIN( 467)				::String _hx_tmp12 = ((_hx_tmp11 + data->get_height()) + HX_(") in atlas ",99,70,14,d3));
HXDLIN( 467)				::String _hx_tmp13 = ((((((_hx_tmp12 + this->name) + HX_(" with the max size of (",b9,b3,66,74)) + this->maxWidth) + HX_("; ",85,33,00,00)) + this->maxHeight) + HX_(") and powerOfTwo: ",d6,69,4d,94));
HXDLIN( 467)				HX_STACK_DO_THROW((_hx_tmp13 + ::Std_obj::string(this->powerOfTwo)));
            			}
HXLINE( 476)			int addRightArea = (addRightWidth * addRightHeight);
HXLINE( 477)			int addBottomArea = (addBottomWidth * addBottomHeight);
HXLINE( 479)			int addRightAreaRotate = (addRightWidthRotate * addRightHeightRotate);
HXLINE( 480)			int addBottomAreaRotate = (addBottomWidthRotate * addBottomHeightRotate);
HXLINE( 482)			bool rotateRight = false;
HXLINE( 483)			bool rotateBottom = false;
HXLINE( 484)			bool rotateNode = false;
HXLINE( 486)			bool _hx_tmp14;
HXDLIN( 486)			bool _hx_tmp15;
HXDLIN( 486)			bool _hx_tmp16;
HXDLIN( 486)			if (canExpandRight) {
HXLINE( 486)				_hx_tmp16 = canExpandRightRotate;
            			}
            			else {
HXLINE( 486)				_hx_tmp16 = false;
            			}
HXDLIN( 486)			if (_hx_tmp16) {
HXLINE( 486)				_hx_tmp15 = (addRightArea > addRightAreaRotate);
            			}
            			else {
HXLINE( 486)				_hx_tmp15 = false;
            			}
HXDLIN( 486)			if (!(_hx_tmp15)) {
HXLINE( 487)				if (!(canExpandRight)) {
HXLINE( 486)					_hx_tmp14 = canExpandRightRotate;
            				}
            				else {
HXLINE( 486)					_hx_tmp14 = false;
            				}
            			}
            			else {
HXLINE( 486)				_hx_tmp14 = true;
            			}
HXDLIN( 486)			if (_hx_tmp14) {
HXLINE( 489)				addRightArea = addBottomAreaRotate;
HXLINE( 490)				addRightWidth = addRightWidthRotate;
HXLINE( 491)				addRightHeight = addRightHeightRotate;
HXLINE( 492)				canExpandRight = true;
HXLINE( 493)				rotateRight = true;
            			}
HXLINE( 496)			bool _hx_tmp17;
HXDLIN( 496)			bool _hx_tmp18;
HXDLIN( 496)			bool _hx_tmp19;
HXDLIN( 496)			if (canExpandBottom) {
HXLINE( 496)				_hx_tmp19 = canExpandBottomRotate;
            			}
            			else {
HXLINE( 496)				_hx_tmp19 = false;
            			}
HXDLIN( 496)			if (_hx_tmp19) {
HXLINE( 496)				_hx_tmp18 = (addBottomArea > addBottomAreaRotate);
            			}
            			else {
HXLINE( 496)				_hx_tmp18 = false;
            			}
HXDLIN( 496)			if (!(_hx_tmp18)) {
HXLINE( 497)				if (!(canExpandBottom)) {
HXLINE( 496)					_hx_tmp17 = canExpandBottomRotate;
            				}
            				else {
HXLINE( 496)					_hx_tmp17 = false;
            				}
            			}
            			else {
HXLINE( 496)				_hx_tmp17 = true;
            			}
HXDLIN( 496)			if (_hx_tmp17) {
HXLINE( 499)				addBottomArea = addBottomAreaRotate;
HXLINE( 500)				addBottomWidth = addBottomWidthRotate;
HXLINE( 501)				addBottomHeight = addBottomHeightRotate;
HXLINE( 502)				canExpandBottom = true;
HXLINE( 503)				rotateBottom = true;
            			}
HXLINE( 506)			bool _hx_tmp20;
HXDLIN( 506)			if (!(canExpandRight)) {
HXLINE( 506)				_hx_tmp20 = canExpandBottom;
            			}
            			else {
HXLINE( 506)				_hx_tmp20 = false;
            			}
HXDLIN( 506)			if (_hx_tmp20) {
HXLINE( 508)				addRightArea = (addBottomArea + (int)1);
HXLINE( 509)				rotateNode = rotateRight;
            			}
            			else {
HXLINE( 511)				bool _hx_tmp21;
HXDLIN( 511)				if (canExpandRight) {
HXLINE( 511)					_hx_tmp21 = !(canExpandBottom);
            				}
            				else {
HXLINE( 511)					_hx_tmp21 = false;
            				}
HXDLIN( 511)				if (_hx_tmp21) {
HXLINE( 513)					addBottomArea = (addRightArea + (int)1);
HXLINE( 514)					rotateNode = rotateBottom;
            				}
            			}
HXLINE( 517)			 ::flixel::graphics::atlas::FlxNode dataNode = null();
HXLINE( 518)			 ::flixel::graphics::atlas::FlxNode temp = this->root;
HXLINE( 519)			int insertNodeWidth = insertWidth1;
HXLINE( 520)			int insertNodeHeight = insertHeight1;
HXLINE( 523)			if ((addBottomArea >= addRightArea)) {
HXLINE( 525)				if (rotateRight) {
HXLINE( 527)					insertNodeWidth = insertHeight1;
HXLINE( 528)					insertNodeHeight = insertWidth1;
            				}
HXLINE( 531)				int _hx_tmp22 = (::Std_obj::_hx_int(temp->rect->width) + insertNodeWidth);
HXDLIN( 531)				this->expandRoot(_hx_tmp22,::Math_obj::max(::Std_obj::_hx_int(temp->rect->height),insertNodeHeight),true,null());
HXLINE( 532)				dataNode = this->divideNode(this->root->right,insertNodeWidth,insertNodeHeight,true,data,key,rotateRight);
HXLINE( 533)				this->expandRoot(addRightWidth,addRightHeight,false,true);
            			}
            			else {
HXLINE( 537)				if (rotateBottom) {
HXLINE( 539)					insertNodeWidth = insertHeight1;
HXLINE( 540)					insertNodeHeight = insertWidth1;
            				}
HXLINE( 543)				Float _hx_tmp23 = ::Math_obj::max(::Std_obj::_hx_int(temp->rect->width),insertNodeWidth);
HXDLIN( 543)				this->expandRoot(_hx_tmp23,(::Std_obj::_hx_int(temp->rect->height) + insertNodeHeight),false,null());
HXLINE( 544)				dataNode = this->divideNode(this->root->right,insertNodeWidth,insertNodeHeight,true,data,key,rotateBottom);
HXLINE( 545)				this->expandRoot(addBottomWidth,addBottomHeight,false,true);
            			}
HXLINE( 548)			return dataNode;
            		}
HXLINE( 551)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,expand,return )

void FlxAtlas_obj::expandRoot(Float newWidth,Float newHeight,bool divideHorizontally,hx::Null< bool >  __o_decideHowToDivide){
bool decideHowToDivide = __o_decideHowToDivide.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_557_expandRoot)
HXDLIN( 557)		bool _hx_tmp;
HXDLIN( 557)		if (!((newWidth > ::Std_obj::_hx_int(this->root->rect->width)))) {
HXDLIN( 557)			_hx_tmp = (newHeight > ::Std_obj::_hx_int(this->root->rect->height));
            		}
            		else {
HXDLIN( 557)			_hx_tmp = true;
            		}
HXDLIN( 557)		if (_hx_tmp) {
HXLINE( 559)			 ::flixel::graphics::atlas::FlxNode temp = this->root;
HXLINE( 560)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 560)			_this->x = (int)0;
HXDLIN( 560)			_this->y = (int)0;
HXDLIN( 560)			_this->width = newWidth;
HXDLIN( 560)			_this->height = newHeight;
HXDLIN( 560)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 560)			rect->_inPool = false;
HXDLIN( 560)			this->root =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 562)			if (decideHowToDivide) {
HXLINE( 562)				 ::flixel::graphics::atlas::FlxNode divideHorizontally1 = this->root;
HXDLIN( 562)				int divideHorizontally2 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 562)				divideHorizontally = this->needToDivideHorizontally(divideHorizontally1,divideHorizontally2,::Std_obj::_hx_int(temp->rect->height));
            			}
            			else {
HXLINE( 562)				divideHorizontally = divideHorizontally;
            			}
HXLINE( 564)			 ::flixel::graphics::atlas::FlxNode _hx_tmp1 = this->root;
HXDLIN( 564)			int _hx_tmp2 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 564)			this->divideNode(_hx_tmp1,_hx_tmp2,::Std_obj::_hx_int(temp->rect->height),divideHorizontally,null(),null(),null());
HXLINE( 565)			this->root->left->left = temp;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxAtlas_obj,expandRoot,(void))

void FlxAtlas_obj::expandBitmapData(){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_570_expandBitmapData)
HXLINE( 571)		bool _hx_tmp;
HXDLIN( 571)		bool _hx_tmp1;
HXDLIN( 571)		if (hx::IsNotNull( this->bitmapData )) {
HXLINE( 571)			int _hx_tmp2 = this->bitmapData->get_width();
HXDLIN( 571)			_hx_tmp1 = (_hx_tmp2 == ::Std_obj::_hx_int(this->root->rect->width));
            		}
            		else {
HXLINE( 571)			_hx_tmp1 = false;
            		}
HXDLIN( 571)		if (_hx_tmp1) {
HXLINE( 571)			int _hx_tmp3 = this->bitmapData->get_height();
HXDLIN( 571)			_hx_tmp = (_hx_tmp3 == ::Std_obj::_hx_int(this->root->rect->height));
            		}
            		else {
HXLINE( 571)			_hx_tmp = false;
            		}
HXDLIN( 571)		if (_hx_tmp) {
HXLINE( 573)			return;
            		}
HXLINE( 576)		int newBitmapData = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 576)		 ::openfl::_legacy::display::BitmapData newBitmapData1 =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,newBitmapData,::Std_obj::_hx_int(this->root->rect->height),true,(int)0,null());
HXLINE( 577)		if (hx::IsNotNull( this->bitmapData )) {
HXLINE( 579)			::flixel::graphics::atlas::FlxAtlas_obj::point->setTo((int)0,(int)0);
HXLINE( 580)			 ::openfl::_legacy::display::BitmapData _hx_tmp4 = this->bitmapData;
HXDLIN( 580)			 ::openfl::_legacy::geom::Rectangle _hx_tmp5 = this->bitmapData->get_rect();
HXDLIN( 580)			newBitmapData1->copyPixels(_hx_tmp4,_hx_tmp5,::flixel::graphics::atlas::FlxAtlas_obj::point,null(),null(),null());
            		}
HXLINE( 583)		this->set_bitmapData(::flixel::util::FlxDestroyUtil_obj::dispose(this->bitmapData));
HXLINE( 584)		this->set_bitmapData(newBitmapData1);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,expandBitmapData,(void))

int FlxAtlas_obj::getNextPowerOfTwo(Float number){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_588_getNextPowerOfTwo)
HXLINE( 589)		int n = ::Std_obj::_hx_int(number);
HXLINE( 590)		bool _hx_tmp;
HXDLIN( 590)		if ((n > (int)0)) {
HXLINE( 590)			_hx_tmp = (((int)n & (int)(n - (int)1)) == (int)0);
            		}
            		else {
HXLINE( 590)			_hx_tmp = false;
            		}
HXDLIN( 590)		if (_hx_tmp) {
HXLINE( 591)			return n;
            		}
HXLINE( 593)		int result = (int)1;
HXLINE( 594)		while((result < n)){
HXLINE( 594)			result = ((int)result << (int)(int)1);
            		}
HXLINE( 595)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,getNextPowerOfTwo,return )

 ::flixel::graphics::frames::FlxTileFrames FlxAtlas_obj::addNodeWithSpacesAndBorders( ::Dynamic Graphic,::String Key, ::flixel::math::FlxPoint tileSize, ::flixel::math::FlxPoint tileSpacing, ::flixel::math::FlxPoint tileBorder, ::flixel::math::FlxRect region){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_613_addNodeWithSpacesAndBorders)
HXLINE( 614)		::String key = ::flixel::_hx_system::FlxAssets_obj::resolveKey(Graphic,Key);
HXLINE( 616)		if (hx::IsNull( key )) {
HXLINE( 619)			HX_STACK_DO_THROW((HX_("addNodeWithSpacings can't find the key for specified BitmapData.",41,5c,a7,0a) + HX_(" Please provide not null value as a Key argument.",09,c1,63,d1)));
            		}
HXLINE( 625)		key = ::flixel::FlxG_obj::bitmap->getKeyWithSpacesAndBorders(key,tileSize,tileSpacing,tileBorder,region);
HXLINE( 627)		if (this->hasNodeWithName(key)) {
HXLINE( 628)			return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >()->getTileFrames(tileSize,tileSpacing,tileBorder);
            		}
HXLINE( 630)		 ::openfl::_legacy::display::BitmapData data = ::flixel::_hx_system::FlxAssets_obj::resolveBitmapData(Graphic);
HXLINE( 632)		if (hx::IsNull( data )) {
HXLINE( 635)			HX_STACK_DO_THROW(((HX_("addNodeWithSpacings can't find BitmapData with specified key: ",e5,6a,ec,e9) + Graphic) + HX_(". Please provide valid value.",84,e6,88,32)));
            		}
HXLINE( 641)		 ::openfl::_legacy::display::BitmapData nodeData = ::flixel::util::FlxBitmapDataUtil_obj::addSpacesAndBorders(data,tileSize,tileSpacing,tileBorder,region);
HXLINE( 642)		 ::flixel::graphics::atlas::FlxNode node = this->addNode(nodeData,key);
HXLINE( 644)		if (hx::IsNull( node )) {
HXLINE( 647)			HX_STACK_DO_THROW(((HX_("addNodeWithSpacings can't insert provided image: ",a1,49,3a,35) + Graphic) + HX_(") in atlas. It's probably too big.",a7,39,69,92)));
            		}
HXLINE( 653)		if (hx::IsNotNull( tileBorder )) {
HXLINE( 654)			Float Y = ((int)2 * tileBorder->y);
HXDLIN( 654)			{
HXLINE( 654)				 ::flixel::math::FlxPoint _g = tileSize;
HXDLIN( 654)				_g->set_x((_g->x + ((int)2 * tileBorder->x)));
            			}
HXDLIN( 654)			{
HXLINE( 654)				 ::flixel::math::FlxPoint _g1 = tileSize;
HXDLIN( 654)				_g1->set_y((_g1->y + Y));
            			}
            		}
HXLINE( 656)		return node->getTileFrames(tileSize,tileSpacing,tileBorder);
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxAtlas_obj,addNodeWithSpacesAndBorders,return )

 ::flixel::graphics::frames::FlxAtlasFrames FlxAtlas_obj::getAtlasFrames(){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_666_getAtlasFrames)
HXLINE( 667)		 ::flixel::graphics::FlxGraphic graph = this->get_graphic();
HXLINE( 669)		 ::flixel::graphics::frames::FlxAtlasFrames atlasFrames = graph->get_atlasFrames();
HXLINE( 670)		if (hx::IsNull( graph->get_atlasFrames() )) {
HXLINE( 672)			atlasFrames =  ::flixel::graphics::frames::FlxAtlasFrames_obj::__alloc( HX_CTX ,graph,null());
            		}
HXLINE( 675)		{
HXLINE( 675)			 ::Dynamic node = this->nodes->iterator();
HXDLIN( 675)			while(( (bool)(node->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 675)				 ::flixel::graphics::atlas::FlxNode node1 = ( ( ::flixel::graphics::atlas::FlxNode)(node->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 676)				this->addNodeToAtlasFrames(node1);
            			}
            		}
HXLINE( 678)		return atlasFrames;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,getAtlasFrames,return )

void FlxAtlas_obj::addNodeToAtlasFrames( ::flixel::graphics::atlas::FlxNode node){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_682_addNodeToAtlasFrames)
HXLINE( 683)		bool _hx_tmp;
HXDLIN( 683)		bool _hx_tmp1;
HXDLIN( 683)		if (hx::IsNotNull( this->_graphic )) {
HXLINE( 683)			_hx_tmp1 = hx::IsNull( this->_graphic->get_atlasFrames() );
            		}
            		else {
HXLINE( 683)			_hx_tmp1 = true;
            		}
HXDLIN( 683)		if (!(_hx_tmp1)) {
HXLINE( 683)			_hx_tmp = hx::IsNull( node );
            		}
            		else {
HXLINE( 683)			_hx_tmp = true;
            		}
HXDLIN( 683)		if (_hx_tmp) {
HXLINE( 684)			return;
            		}
HXLINE( 686)		 ::flixel::graphics::frames::FlxAtlasFrames atlasFrames = this->_graphic->get_atlasFrames();
HXLINE( 688)		bool _hx_tmp2;
HXDLIN( 688)		if (node->filled) {
HXLINE( 688)			_hx_tmp2 = !(atlasFrames->framesHash->exists(node->key));
            		}
            		else {
HXLINE( 688)			_hx_tmp2 = false;
            		}
HXDLIN( 688)		if (_hx_tmp2) {
HXLINE( 690)			Float X = ::Std_obj::_hx_int(node->rect->x);
HXDLIN( 690)			Float Y = ::Std_obj::_hx_int(node->rect->y);
HXDLIN( 690)			int Width = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 690)			Float Width1 = (Width - this->border);
HXDLIN( 690)			int Height = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 690)			Float Height1 = (Height - this->border);
HXDLIN( 690)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 690)			_this->x = X;
HXDLIN( 690)			_this->y = Y;
HXDLIN( 690)			_this->width = Width1;
HXDLIN( 690)			_this->height = Height1;
HXDLIN( 690)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 690)			rect->_inPool = false;
HXDLIN( 690)			 ::flixel::math::FlxRect frame = rect;
HXLINE( 691)			 ::flixel::math::FlxPoint sourceSize;
HXDLIN( 691)			if (node->rotated) {
HXLINE( 692)				int X1 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 692)				Float X2 = (X1 - this->border);
HXDLIN( 692)				int Y1 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 692)				Float Y2 = (Y1 - this->border);
HXDLIN( 692)				 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(X2,Y2);
HXDLIN( 692)				point->_inPool = false;
HXLINE( 691)				sourceSize = point;
            			}
            			else {
HXLINE( 693)				int X3 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 693)				Float X4 = (X3 - this->border);
HXDLIN( 693)				int Y3 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 693)				Float Y4 = (Y3 - this->border);
HXDLIN( 693)				 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set(X4,Y4);
HXDLIN( 693)				point1->_inPool = false;
HXLINE( 691)				sourceSize = point1;
            			}
HXLINE( 694)			 ::flixel::math::FlxPoint point2 = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN( 694)			point2->_inPool = false;
HXDLIN( 694)			 ::flixel::math::FlxPoint offset = point2;
HXLINE( 695)			int angle;
HXDLIN( 695)			if (node->rotated) {
HXLINE( 695)				angle = (int)-90;
            			}
            			else {
HXLINE( 695)				angle = (int)0;
            			}
HXLINE( 696)			atlasFrames->addAtlasFrame(frame,sourceSize,offset,node->key,angle,null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,addNodeToAtlasFrames,(void))

bool FlxAtlas_obj::hasNodeWithName(::String nodeName){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_708_hasNodeWithName)
HXDLIN( 708)		return this->nodes->exists(nodeName);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,hasNodeWithName,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::getNode(::String key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_719_getNode)
HXDLIN( 719)		return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,getNode,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::addNodes(::Array< ::Dynamic> bitmaps,::Array< ::String > keys){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_731_addNodes)
HXLINE( 732)		int numKeys = keys->length;
HXLINE( 733)		int numBitmaps = bitmaps->length;
HXLINE( 735)		if ((numBitmaps != numKeys)) {
HXLINE( 738)			HX_STACK_DO_THROW(((((HX_("The number of bitmaps (",cb,e8,a2,a6) + numBitmaps) + HX_(") should be equal to number of keys (",a0,90,37,97)) + numKeys) + HX_(")",29,00,00,00)));
            		}
HXLINE( 743)		this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
HXLINE( 744)		{
HXLINE( 744)			int _g1 = (int)0;
HXDLIN( 744)			int _g = numBitmaps;
HXDLIN( 744)			while((_g1 < _g)){
HXLINE( 744)				_g1 = (_g1 + (int)1);
HXDLIN( 744)				int i = (_g1 - (int)1);
HXLINE( 746)				this->_tempStorage->push( ::Dynamic(hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("bmd",39,bc,4a,00),bitmaps->__get(i).StaticCast<  ::openfl::_legacy::display::BitmapData >())
            					->setFixed(1,HX_("keyStr",52,64,e2,3f),keys->__get(i))));
            			}
            		}
HXLINE( 749)		this->addFromAtlasObjects(this->_tempStorage);
HXLINE( 750)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addNodes,return )

void FlxAtlas_obj::addFromAtlasObjects(::Array< ::Dynamic> objects){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_754_addFromAtlasObjects)
HXLINE( 755)		objects->sort(this->bitmapSorter_dyn());
HXLINE( 756)		int numBitmaps = objects->length;
HXLINE( 758)		{
HXLINE( 758)			int _g1 = (int)0;
HXDLIN( 758)			int _g = numBitmaps;
HXDLIN( 758)			while((_g1 < _g)){
HXLINE( 758)				_g1 = (_g1 + (int)1);
HXDLIN( 758)				int i = (_g1 - (int)1);
HXLINE( 759)				this->addNode( ::Dynamic(objects->__get(i)->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)),( (::String)(objects->__get(i)->__Field(HX_("keyStr",52,64,e2,3f),hx::paccDynamic)) ));
            			}
            		}
HXLINE( 761)		this->_tempStorage = null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,addFromAtlasObjects,(void))

int FlxAtlas_obj::bitmapSorter( ::Dynamic obj1, ::Dynamic obj2){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_768_bitmapSorter)
HXLINE( 769)		if (this->allowRotation) {
HXLINE( 771)			int area1 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 771)			int area11 = (area1 * ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height());
HXLINE( 772)			int area2 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 772)			int area21 = (area2 * ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height());
HXLINE( 773)			return (area21 - area11);
            		}
HXLINE( 776)		int _hx_tmp = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 776)		if ((_hx_tmp == ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width())) {
HXLINE( 777)			int _hx_tmp1 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height();
HXDLIN( 777)			return (_hx_tmp1 - ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height());
            		}
HXLINE( 779)		int _hx_tmp2 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 779)		return (_hx_tmp2 - ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width());
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,bitmapSorter,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::createQueue(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_790_createQueue)
HXLINE( 791)		this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
HXLINE( 792)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,createQueue,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::addToQueue( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_802_addToQueue)
HXLINE( 803)		if (hx::IsNull( this->_tempStorage )) {
HXLINE( 804)			this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 806)		this->_tempStorage->push( ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("bmd",39,bc,4a,00),data)
            			->setFixed(1,HX_("keyStr",52,64,e2,3f),key)));
HXLINE( 807)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addToQueue,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::generateFromQueue(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_814_generateFromQueue)
HXLINE( 815)		if (hx::IsNotNull( this->_tempStorage )) {
HXLINE( 816)			this->addFromAtlasObjects(this->_tempStorage);
            		}
HXLINE( 818)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,generateFromQueue,return )

void FlxAtlas_obj::onClear( ::flixel::FlxState _){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_823_onClear)
HXDLIN( 823)		bool _hx_tmp;
HXDLIN( 823)		if (!(!(this->persist))) {
HXDLIN( 823)			if (hx::IsNotNull( this->_graphic )) {
HXDLIN( 823)				_hx_tmp = (this->_graphic->get_useCount() <= (int)0);
            			}
            			else {
HXDLIN( 823)				_hx_tmp = false;
            			}
            		}
            		else {
HXDLIN( 823)			_hx_tmp = true;
            		}
HXDLIN( 823)		if (_hx_tmp) {
HXLINE( 824)			this->destroy();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,onClear,(void))

void FlxAtlas_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_832_destroy)
HXLINE( 833)		this->_tempStorage = null();
HXLINE( 834)		this->deleteSubtree(this->root);
HXLINE( 835)		this->root = null();
HXLINE( 836)		::flixel::FlxG_obj::bitmap->removeByKey(this->name);
HXLINE( 837)		this->set_bitmapData(null());
HXLINE( 838)		this->nodes = null();
HXLINE( 839)		this->_graphic = null();
HXLINE( 841)		::flixel::FlxG_obj::signals->preStateCreate->remove(this->onClear_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,destroy,(void))

void FlxAtlas_obj::clear(){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_850_clear)
HXLINE( 851)		this->deleteSubtree(this->root);
HXLINE( 852)		this->initRoot();
HXLINE( 853)		::flixel::FlxG_obj::bitmap->removeByKey(this->name);
HXLINE( 854)		this->set_bitmapData(null());
HXLINE( 855)		this->nodes =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 856)		this->_graphic = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,clear,(void))

::String FlxAtlas_obj::getLibGdxData(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_863_getLibGdxData)
HXLINE( 864)		::String data = HX_("\n",0a,00,00,00);
HXLINE( 865)		data = (data + (this->name + HX_("\n",0a,00,00,00)));
HXLINE( 866)		data = (data + HX_("format: RGBA8888\n",99,1f,ed,c2));
HXLINE( 867)		data = (data + HX_("filter: Linear,Linear\n",9c,47,05,72));
HXLINE( 868)		data = (data + HX_("repeat: none\n",f1,9b,51,ee));
HXLINE( 870)		{
HXLINE( 870)			 ::Dynamic node = this->nodes->iterator();
HXDLIN( 870)			while(( (bool)(node->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 870)				 ::flixel::graphics::atlas::FlxNode node1 = ( ( ::flixel::graphics::atlas::FlxNode)(node->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 872)				data = (data + (node1->key + HX_("\n",0a,00,00,00)));
HXLINE( 873)				data = (data + ((HX_("  rotate: ",c1,21,ff,6f) + ::Std_obj::string(node1->rotated)) + HX_("\n",0a,00,00,00)));
HXLINE( 874)				::String data1 = ((HX_("  xy: ",e7,b9,eb,87) + ::Std_obj::_hx_int(node1->rect->x)) + HX_(", ",74,26,00,00));
HXDLIN( 874)				data = (data + ((data1 + ::Std_obj::_hx_int(node1->rect->y)) + HX_("\n",0a,00,00,00)));
HXLINE( 876)				if (this->allowRotation) {
HXLINE( 878)					::String data2 = ((HX_("size: ",a7,45,0e,c1) + ::Std_obj::_hx_int(node1->rect->height)) + HX_(", ",74,26,00,00));
HXDLIN( 878)					data = (data + ((data2 + ::Std_obj::_hx_int(node1->rect->width)) + HX_("\n",0a,00,00,00)));
HXLINE( 879)					::String data3 = ((HX_("orig: ",a7,f0,00,4b) + ::Std_obj::_hx_int(node1->rect->height)) + HX_(", ",74,26,00,00));
HXDLIN( 879)					data = (data + ((data3 + ::Std_obj::_hx_int(node1->rect->width)) + HX_("\n",0a,00,00,00)));
            				}
            				else {
HXLINE( 883)					::String data4 = ((HX_("size: ",a7,45,0e,c1) + ::Std_obj::_hx_int(node1->rect->width)) + HX_(", ",74,26,00,00));
HXDLIN( 883)					data = (data + ((data4 + ::Std_obj::_hx_int(node1->rect->height)) + HX_("\n",0a,00,00,00)));
HXLINE( 884)					::String data5 = ((HX_("orig: ",a7,f0,00,4b) + ::Std_obj::_hx_int(node1->rect->width)) + HX_(", ",74,26,00,00));
HXDLIN( 884)					data = (data + ((data5 + ::Std_obj::_hx_int(node1->rect->height)) + HX_("\n",0a,00,00,00)));
            				}
HXLINE( 887)				data = (data + HX_("  offset: 0, 0\n",e5,55,b9,3b));
HXLINE( 888)				data = (data + HX_("  index: -1\n",ee,e8,07,0b));
            			}
            		}
HXLINE( 891)		return data;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,getLibGdxData,return )

void FlxAtlas_obj::deleteSubtree( ::flixel::graphics::atlas::FlxNode node){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_896_deleteSubtree)
HXDLIN( 896)		if (hx::IsNotNull( node )) {
HXLINE( 898)			if (hx::IsNotNull( node->left )) {
HXLINE( 898)				this->deleteSubtree(node->left);
            			}
HXLINE( 899)			if (hx::IsNotNull( node->right )) {
HXLINE( 899)				this->deleteSubtree(node->right);
            			}
HXLINE( 900)			{
HXLINE( 900)				node->key = null();
HXDLIN( 900)				node->left = null();
HXDLIN( 900)				node->right = null();
HXDLIN( 900)				node->rect = null();
HXDLIN( 900)				node->atlas = null();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,deleteSubtree,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::findNodeToInsert(int insertWidth,int insertHeight){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_906_findNodeToInsert)
HXLINE( 908)		::Array< ::Dynamic> stack = ::Array_obj< ::Dynamic>::__new();
HXLINE( 910)		 ::flixel::graphics::atlas::FlxNode current = this->root;
HXLINE( 912)		::Array< ::Dynamic> emptyNodes = ::Array_obj< ::Dynamic>::__new();
HXLINE( 914)		bool canPlaceRight = false;
HXLINE( 915)		bool canPlaceLeft = false;
HXLINE( 917)		bool looping = true;
HXLINE( 919)		 ::flixel::graphics::atlas::FlxNode result = null();
HXLINE( 920)		int minArea = ((this->maxWidth * this->maxHeight) + (int)1);
HXLINE( 921)		int nodeArea;
HXLINE( 924)		while(looping){
HXLINE( 927)			bool _hx_tmp;
HXDLIN( 927)			bool _hx_tmp1;
HXDLIN( 927)			bool _hx_tmp2;
HXDLIN( 927)			if (!(current->filled)) {
HXLINE( 927)				_hx_tmp2 = hx::IsNull( current->left );
            			}
            			else {
HXLINE( 927)				_hx_tmp2 = false;
            			}
HXDLIN( 927)			if (_hx_tmp2) {
HXLINE( 927)				_hx_tmp1 = hx::IsNull( current->right );
            			}
            			else {
HXLINE( 927)				_hx_tmp1 = false;
            			}
HXDLIN( 927)			if (_hx_tmp1) {
HXLINE( 927)				if ((current->rect->width >= insertWidth)) {
HXLINE( 927)					_hx_tmp = (current->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 927)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 927)				_hx_tmp = false;
            			}
HXDLIN( 927)			if (_hx_tmp) {
HXLINE( 929)				int nodeArea1 = ::Std_obj::_hx_int(current->rect->width);
HXDLIN( 929)				nodeArea = (nodeArea1 * ::Std_obj::_hx_int(current->rect->height));
HXLINE( 931)				if ((nodeArea < minArea)) {
HXLINE( 933)					minArea = nodeArea;
HXLINE( 934)					result = current;
            				}
            			}
HXLINE( 938)			if (hx::IsNotNull( current->right )) {
HXLINE( 938)				 ::flixel::graphics::atlas::FlxNode _this = current->right;
HXDLIN( 938)				if ((_this->rect->width >= insertWidth)) {
HXLINE( 938)					canPlaceRight = (_this->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 938)					canPlaceRight = false;
            				}
            			}
            			else {
HXLINE( 938)				canPlaceRight = false;
            			}
HXLINE( 939)			if (hx::IsNotNull( current->left )) {
HXLINE( 939)				 ::flixel::graphics::atlas::FlxNode _this1 = current->left;
HXDLIN( 939)				if ((_this1->rect->width >= insertWidth)) {
HXLINE( 939)					canPlaceLeft = (_this1->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 939)					canPlaceLeft = false;
            				}
            			}
            			else {
HXLINE( 939)				canPlaceLeft = false;
            			}
HXLINE( 940)			bool _hx_tmp3;
HXDLIN( 940)			if (canPlaceRight) {
HXLINE( 940)				_hx_tmp3 = canPlaceLeft;
            			}
            			else {
HXLINE( 940)				_hx_tmp3 = false;
            			}
HXDLIN( 940)			if (_hx_tmp3) {
HXLINE( 942)				stack->push(current->right);
HXLINE( 943)				current = current->left;
            			}
            			else {
HXLINE( 945)				if (canPlaceLeft) {
HXLINE( 947)					current = current->left;
            				}
            				else {
HXLINE( 949)					if (canPlaceRight) {
HXLINE( 951)						current = current->right;
            					}
            					else {
HXLINE( 955)						if ((stack->length > (int)0)) {
HXLINE( 958)							current = stack->pop().StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            						}
            						else {
HXLINE( 963)							looping = false;
            						}
            					}
            				}
            			}
            		}
HXLINE( 968)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,findNodeToInsert,return )

 ::openfl::_legacy::display::BitmapData FlxAtlas_obj::set_bitmapData( ::openfl::_legacy::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_972_set_bitmapData)
HXLINE( 974)		bool _hx_tmp;
HXDLIN( 974)		if (hx::IsNotNull( value )) {
HXLINE( 974)			_hx_tmp = hx::IsNotNull( this->_graphic );
            		}
            		else {
HXLINE( 974)			_hx_tmp = false;
            		}
HXDLIN( 974)		if (_hx_tmp) {
HXLINE( 975)			this->_graphic->set_bitmap(value);
            		}
HXLINE( 977)		return (this->bitmapData = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_bitmapData,return )

 ::flixel::graphics::FlxGraphic FlxAtlas_obj::get_graphic(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_981_get_graphic)
HXLINE( 982)		if (hx::IsNotNull( this->_graphic )) {
HXLINE( 983)			return this->_graphic;
            		}
HXLINE( 985)		this->_graphic = ::flixel::FlxG_obj::bitmap->add(this->bitmapData,false,this->name);
HXLINE( 986)		this->_graphic->persist = this->persist;
HXLINE( 988)		return this->_graphic;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_graphic,return )

bool FlxAtlas_obj::set_persist(bool value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_992_set_persist)
HXLINE( 993)		if (hx::IsNotNull( this->_graphic )) {
HXLINE( 994)			this->_graphic->persist = value;
            		}
HXLINE( 996)		return (this->persist = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_persist,return )

int FlxAtlas_obj::set_minWidth(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1000_set_minWidth)
HXLINE(1001)		if ((value <= this->maxWidth)) {
HXLINE(1003)			this->minWidth = value;
HXLINE(1004)			if ((value > this->get_width())) {
HXLINE(1005)				this->set_width(value);
            			}
            		}
HXLINE(1008)		return this->minWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_minWidth,return )

int FlxAtlas_obj::set_minHeight(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1012_set_minHeight)
HXLINE(1013)		if ((value <= this->maxHeight)) {
HXLINE(1015)			this->minHeight = value;
HXLINE(1016)			if ((value > this->get_height())) {
HXLINE(1017)				this->set_height(value);
            			}
            		}
HXLINE(1020)		return this->minHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_minHeight,return )

int FlxAtlas_obj::get_width(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1024_get_width)
HXLINE(1025)		if (hx::IsNotNull( this->root )) {
HXLINE(1026)			return ::Std_obj::_hx_int(this->root->rect->width);
            		}
HXLINE(1028)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_width,return )

int FlxAtlas_obj::set_width(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1032_set_width)
HXLINE(1033)		if ((value > this->get_width())) {
HXLINE(1035)			if (this->powerOfTwo) {
HXLINE(1036)				value = this->getNextPowerOfTwo(value);
            			}
HXLINE(1038)			if ((value <= this->maxWidth)) {
HXLINE(1040)				bool _hx_tmp;
HXDLIN(1040)				if (hx::IsNotNull( this->root )) {
HXLINE(1040)					_hx_tmp = (::Std_obj::_hx_int(this->root->rect->width) < value);
            				}
            				else {
HXLINE(1040)					_hx_tmp = false;
            				}
HXDLIN(1040)				if (_hx_tmp) {
HXLINE(1042)					int _hx_tmp1 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1042)					 ::flixel::graphics::atlas::FlxNode _hx_tmp2 = this->root;
HXDLIN(1042)					int _hx_tmp3 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1042)					this->expandRoot(value,_hx_tmp1,this->needToDivideHorizontally(_hx_tmp2,_hx_tmp3,::Std_obj::_hx_int(this->root->rect->height)),null());
            				}
            			}
            		}
HXLINE(1047)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_width,return )

int FlxAtlas_obj::get_height(){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1051_get_height)
HXLINE(1052)		if (hx::IsNotNull( this->root )) {
HXLINE(1053)			return ::Std_obj::_hx_int(this->root->rect->height);
            		}
HXLINE(1054)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_height,return )

int FlxAtlas_obj::set_height(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1058_set_height)
HXLINE(1059)		if ((value > this->get_height())) {
HXLINE(1061)			if (this->powerOfTwo) {
HXLINE(1062)				value = this->getNextPowerOfTwo(value);
            			}
HXLINE(1064)			if ((value <= this->maxHeight)) {
HXLINE(1066)				bool _hx_tmp;
HXDLIN(1066)				if (hx::IsNotNull( this->root )) {
HXLINE(1066)					_hx_tmp = (::Std_obj::_hx_int(this->root->rect->height) < value);
            				}
            				else {
HXLINE(1066)					_hx_tmp = false;
            				}
HXDLIN(1066)				if (_hx_tmp) {
HXLINE(1068)					int _hx_tmp1 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1068)					 ::flixel::graphics::atlas::FlxNode _hx_tmp2 = this->root;
HXDLIN(1068)					int _hx_tmp3 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1068)					this->expandRoot(_hx_tmp1,value,this->needToDivideHorizontally(_hx_tmp2,_hx_tmp3,::Std_obj::_hx_int(this->root->rect->height)),null());
            				}
            			}
            		}
HXLINE(1073)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_height,return )

int FlxAtlas_obj::set_maxWidth(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1077_set_maxWidth)
HXLINE(1078)		bool _hx_tmp;
HXDLIN(1078)		if ((value >= this->minWidth)) {
HXLINE(1078)			if (hx::IsNotNull( this->root )) {
HXLINE(1078)				_hx_tmp = (value >= this->get_width());
            			}
            			else {
HXLINE(1078)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE(1078)			_hx_tmp = false;
            		}
HXDLIN(1078)		if (_hx_tmp) {
HXLINE(1079)			this->maxWidth = value;
            		}
HXLINE(1081)		return this->maxWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_maxWidth,return )

int FlxAtlas_obj::set_maxHeight(int value){
            	HX_STACKFRAME(&_hx_pos_f38becfab6571882_1085_set_maxHeight)
HXLINE(1086)		bool _hx_tmp;
HXDLIN(1086)		if ((value >= this->minHeight)) {
HXLINE(1086)			if (hx::IsNotNull( this->root )) {
HXLINE(1086)				_hx_tmp = (value >= this->get_height());
            			}
            			else {
HXLINE(1086)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE(1086)			_hx_tmp = false;
            		}
HXDLIN(1086)		if (_hx_tmp) {
HXLINE(1087)			this->maxHeight = value;
            		}
HXLINE(1089)		return this->maxHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_maxHeight,return )

bool FlxAtlas_obj::set_powerOfTwo(bool value){
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_1093_set_powerOfTwo)
HXLINE(1094)		bool _hx_tmp;
HXDLIN(1094)		bool _hx_tmp1;
HXDLIN(1094)		if ((value != this->powerOfTwo)) {
HXLINE(1094)			_hx_tmp1 = value;
            		}
            		else {
HXLINE(1094)			_hx_tmp1 = false;
            		}
HXDLIN(1094)		if (_hx_tmp1) {
HXLINE(1094)			_hx_tmp = hx::IsNotNull( this->root );
            		}
            		else {
HXLINE(1094)			_hx_tmp = false;
            		}
HXDLIN(1094)		if (_hx_tmp) {
HXLINE(1096)			int nextWidth = this->getNextPowerOfTwo(::Std_obj::_hx_int(this->root->rect->width));
HXLINE(1097)			int nextHeight = this->getNextPowerOfTwo(::Std_obj::_hx_int(this->root->rect->height));
HXLINE(1099)			bool _hx_tmp2;
HXDLIN(1099)			if ((nextWidth == ::Std_obj::_hx_int(this->root->rect->width))) {
HXLINE(1099)				_hx_tmp2 = (nextHeight != ::Std_obj::_hx_int(this->root->rect->height));
            			}
            			else {
HXLINE(1099)				_hx_tmp2 = true;
            			}
HXDLIN(1099)			if (_hx_tmp2) {
HXLINE(1101)				bool _hx_tmp3;
HXDLIN(1101)				bool _hx_tmp4;
HXDLIN(1101)				if ((this->maxWidth > (int)0)) {
HXLINE(1101)					_hx_tmp4 = (nextWidth > this->maxWidth);
            				}
            				else {
HXLINE(1101)					_hx_tmp4 = false;
            				}
HXDLIN(1101)				if (!(_hx_tmp4)) {
HXLINE(1101)					if ((this->maxHeight > (int)0)) {
HXLINE(1101)						_hx_tmp3 = (nextHeight > this->maxHeight);
            					}
            					else {
HXLINE(1101)						_hx_tmp3 = false;
            					}
            				}
            				else {
HXLINE(1101)					_hx_tmp3 = true;
            				}
HXDLIN(1101)				if (_hx_tmp3) {
HXLINE(1104)					HX_STACK_DO_THROW((HX_("Can't set powerOfTwo property to true,",95,3e,d2,3d) + HX_(" since it requires to increase atlas size which is bigger that max size",8f,79,d1,e8)));
            				}
HXLINE(1110)				 ::flixel::graphics::atlas::FlxNode temp = this->root;
HXLINE(1111)				 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN(1111)				_this->x = (int)0;
HXDLIN(1111)				_this->y = (int)0;
HXDLIN(1111)				_this->width = nextWidth;
HXDLIN(1111)				_this->height = nextHeight;
HXDLIN(1111)				 ::flixel::math::FlxRect rect = _this;
HXDLIN(1111)				rect->_inPool = false;
HXDLIN(1111)				this->root =  ::flixel::graphics::atlas::FlxNode_obj::__alloc( HX_CTX ,rect,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE(1113)				if (hx::IsNotNull( temp->left )) {
HXLINE(1115)					 ::flixel::graphics::atlas::FlxNode _hx_tmp5 = this->root;
HXDLIN(1115)					int _hx_tmp6 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN(1115)					int _hx_tmp7 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN(1115)					 ::flixel::graphics::atlas::FlxNode _hx_tmp8 = this->root;
HXDLIN(1115)					int _hx_tmp9 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN(1115)					this->divideNode(_hx_tmp5,_hx_tmp6,_hx_tmp7,this->needToDivideHorizontally(_hx_tmp8,_hx_tmp9,::Std_obj::_hx_int(temp->rect->height)),null(),null(),null());
HXLINE(1116)					this->root->left->left = temp;
            				}
            			}
            		}
HXLINE(1121)		return (this->powerOfTwo = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_powerOfTwo,return )

 ::openfl::_legacy::geom::Point FlxAtlas_obj::point;

 ::openfl::_legacy::geom::Matrix FlxAtlas_obj::matrix;

 ::flixel::math::FlxPoint FlxAtlas_obj::defaultMinSize;

 ::flixel::math::FlxPoint FlxAtlas_obj::defaultMaxSize;


hx::ObjectPtr< FlxAtlas_obj > FlxAtlas_obj::__new(::String name,hx::Null< bool >  __o_powerOfTwo,hx::Null< int >  __o_border,hx::Null< bool >  __o_rotate, ::flixel::math::FlxPoint minSize, ::flixel::math::FlxPoint maxSize) {
	hx::ObjectPtr< FlxAtlas_obj > __this = new FlxAtlas_obj();
	__this->__construct(name,__o_powerOfTwo,__o_border,__o_rotate,minSize,maxSize);
	return __this;
}

hx::ObjectPtr< FlxAtlas_obj > FlxAtlas_obj::__alloc(hx::Ctx *_hx_ctx,::String name,hx::Null< bool >  __o_powerOfTwo,hx::Null< int >  __o_border,hx::Null< bool >  __o_rotate, ::flixel::math::FlxPoint minSize, ::flixel::math::FlxPoint maxSize) {
	FlxAtlas_obj *__this = (FlxAtlas_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxAtlas_obj), true, "flixel.graphics.atlas.FlxAtlas"));
	*(void **)__this = FlxAtlas_obj::_hx_vtable;
	__this->__construct(name,__o_powerOfTwo,__o_border,__o_rotate,minSize,maxSize);
	return __this;
}

FlxAtlas_obj::FlxAtlas_obj()
{
}

void FlxAtlas_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxAtlas);
	HX_MARK_MEMBER_NAME(root,"root");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(nodes,"nodes");
	HX_MARK_MEMBER_NAME(bitmapData,"bitmapData");
	HX_MARK_MEMBER_NAME(graphic,"graphic");
	HX_MARK_MEMBER_NAME(persist,"persist");
	HX_MARK_MEMBER_NAME(border,"border");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(minWidth,"minWidth");
	HX_MARK_MEMBER_NAME(minHeight,"minHeight");
	HX_MARK_MEMBER_NAME(maxWidth,"maxWidth");
	HX_MARK_MEMBER_NAME(maxHeight,"maxHeight");
	HX_MARK_MEMBER_NAME(allowRotation,"allowRotation");
	HX_MARK_MEMBER_NAME(powerOfTwo,"powerOfTwo");
	HX_MARK_MEMBER_NAME(_graphic,"_graphic");
	HX_MARK_MEMBER_NAME(_tempStorage,"_tempStorage");
	HX_MARK_END_CLASS();
}

void FlxAtlas_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(root,"root");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(nodes,"nodes");
	HX_VISIT_MEMBER_NAME(bitmapData,"bitmapData");
	HX_VISIT_MEMBER_NAME(graphic,"graphic");
	HX_VISIT_MEMBER_NAME(persist,"persist");
	HX_VISIT_MEMBER_NAME(border,"border");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(minWidth,"minWidth");
	HX_VISIT_MEMBER_NAME(minHeight,"minHeight");
	HX_VISIT_MEMBER_NAME(maxWidth,"maxWidth");
	HX_VISIT_MEMBER_NAME(maxHeight,"maxHeight");
	HX_VISIT_MEMBER_NAME(allowRotation,"allowRotation");
	HX_VISIT_MEMBER_NAME(powerOfTwo,"powerOfTwo");
	HX_VISIT_MEMBER_NAME(_graphic,"_graphic");
	HX_VISIT_MEMBER_NAME(_tempStorage,"_tempStorage");
}

hx::Val FlxAtlas_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"root") ) { return hx::Val( root ); }
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nodes") ) { return hx::Val( nodes ); }
		if (HX_FIELD_EQ(inName,"width") ) { return hx::Val( inCallProp == hx::paccAlways ? get_width() : width ); }
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { return hx::Val( border ); }
		if (HX_FIELD_EQ(inName,"height") ) { return hx::Val( inCallProp == hx::paccAlways ? get_height() : height ); }
		if (HX_FIELD_EQ(inName,"expand") ) { return hx::Val( expand_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { return hx::Val( inCallProp == hx::paccAlways ? get_graphic() : graphic ); }
		if (HX_FIELD_EQ(inName,"persist") ) { return hx::Val( persist ); }
		if (HX_FIELD_EQ(inName,"addNode") ) { return hx::Val( addNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"getNode") ) { return hx::Val( getNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"onClear") ) { return hx::Val( onClear_dyn() ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"minWidth") ) { return hx::Val( minWidth ); }
		if (HX_FIELD_EQ(inName,"maxWidth") ) { return hx::Val( maxWidth ); }
		if (HX_FIELD_EQ(inName,"_graphic") ) { return hx::Val( _graphic ); }
		if (HX_FIELD_EQ(inName,"initRoot") ) { return hx::Val( initRoot_dyn() ); }
		if (HX_FIELD_EQ(inName,"wrapRoot") ) { return hx::Val( wrapRoot_dyn() ); }
		if (HX_FIELD_EQ(inName,"addNodes") ) { return hx::Val( addNodes_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"minHeight") ) { return hx::Val( minHeight ); }
		if (HX_FIELD_EQ(inName,"maxHeight") ) { return hx::Val( maxHeight ); }
		if (HX_FIELD_EQ(inName,"tryInsert") ) { return hx::Val( tryInsert_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_width") ) { return hx::Val( get_width_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_width") ) { return hx::Val( set_width_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { return hx::Val( bitmapData ); }
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { return hx::Val( powerOfTwo ); }
		if (HX_FIELD_EQ(inName,"divideNode") ) { return hx::Val( divideNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"expandRoot") ) { return hx::Val( expandRoot_dyn() ); }
		if (HX_FIELD_EQ(inName,"addToQueue") ) { return hx::Val( addToQueue_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_height") ) { return hx::Val( get_height_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_height") ) { return hx::Val( set_height_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createQueue") ) { return hx::Val( createQueue_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_graphic") ) { return hx::Val( get_graphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_persist") ) { return hx::Val( set_persist_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tempStorage") ) { return hx::Val( _tempStorage ); }
		if (HX_FIELD_EQ(inName,"bitmapSorter") ) { return hx::Val( bitmapSorter_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_minWidth") ) { return hx::Val( set_minWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_maxWidth") ) { return hx::Val( set_maxWidth_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"allowRotation") ) { return hx::Val( allowRotation ); }
		if (HX_FIELD_EQ(inName,"getLibGdxData") ) { return hx::Val( getLibGdxData_dyn() ); }
		if (HX_FIELD_EQ(inName,"deleteSubtree") ) { return hx::Val( deleteSubtree_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_minHeight") ) { return hx::Val( set_minHeight_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_maxHeight") ) { return hx::Val( set_maxHeight_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getAtlasFrames") ) { return hx::Val( getAtlasFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_bitmapData") ) { return hx::Val( set_bitmapData_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_powerOfTwo") ) { return hx::Val( set_powerOfTwo_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"hasNodeWithName") ) { return hx::Val( hasNodeWithName_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"expandBitmapData") ) { return hx::Val( expandBitmapData_dyn() ); }
		if (HX_FIELD_EQ(inName,"findNodeToInsert") ) { return hx::Val( findNodeToInsert_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getNextPowerOfTwo") ) { return hx::Val( getNextPowerOfTwo_dyn() ); }
		if (HX_FIELD_EQ(inName,"generateFromQueue") ) { return hx::Val( generateFromQueue_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"addFromAtlasObjects") ) { return hx::Val( addFromAtlasObjects_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"addNodeToAtlasFrames") ) { return hx::Val( addNodeToAtlasFrames_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"insertFirstNodeInRoot") ) { return hx::Val( insertFirstNodeInRoot_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"needToDivideHorizontally") ) { return hx::Val( needToDivideHorizontally_dyn() ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"addNodeWithSpacesAndBorders") ) { return hx::Val( addNodeWithSpacesAndBorders_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxAtlas_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { outValue = ( point ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = ( matrix ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"defaultMinSize") ) { outValue = ( defaultMinSize ); return true; }
		if (HX_FIELD_EQ(inName,"defaultMaxSize") ) { outValue = ( defaultMaxSize ); return true; }
	}
	return false;
}

hx::Val FlxAtlas_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"root") ) { root=inValue.Cast<  ::flixel::graphics::atlas::FlxNode >(); return inValue; }
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nodes") ) { nodes=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"width") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_width(inValue.Cast< int >()) );width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { border=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"height") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_height(inValue.Cast< int >()) );height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"persist") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_persist(inValue.Cast< bool >()) );persist=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"minWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_minWidth(inValue.Cast< int >()) );minWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxWidth(inValue.Cast< int >()) );maxWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_graphic") ) { _graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"minHeight") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_minHeight(inValue.Cast< int >()) );minHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxHeight") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxHeight(inValue.Cast< int >()) );maxHeight=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_bitmapData(inValue.Cast<  ::openfl::_legacy::display::BitmapData >()) );bitmapData=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_powerOfTwo(inValue.Cast< bool >()) );powerOfTwo=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tempStorage") ) { _tempStorage=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"allowRotation") ) { allowRotation=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxAtlas_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { point=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::openfl::_legacy::geom::Matrix >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"defaultMinSize") ) { defaultMinSize=ioValue.Cast<  ::flixel::math::FlxPoint >(); return true; }
		if (HX_FIELD_EQ(inName,"defaultMaxSize") ) { defaultMaxSize=ioValue.Cast<  ::flixel::math::FlxPoint >(); return true; }
	}
	return false;
}

void FlxAtlas_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("root","\x22","\xee","\xae","\x4b"));
	outFields->push(HX_HCSTRING("name","\x4b","\x72","\xff","\x48"));
	outFields->push(HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f"));
	outFields->push(HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33"));
	outFields->push(HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"));
	outFields->push(HX_HCSTRING("persist","\x14","\x22","\x71","\x83"));
	outFields->push(HX_HCSTRING("border","\xec","\x4c","\x1a","\x64"));
	outFields->push(HX_HCSTRING("width","\x06","\xb6","\x62","\xca"));
	outFields->push(HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"));
	outFields->push(HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1"));
	outFields->push(HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b"));
	outFields->push(HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74"));
	outFields->push(HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31"));
	outFields->push(HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9"));
	outFields->push(HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea"));
	outFields->push(HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad"));
	outFields->push(HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxAtlas_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::graphics::atlas::FlxNode*/ ,(int)offsetof(FlxAtlas_obj,root),HX_HCSTRING("root","\x22","\xee","\xae","\x4b")},
	{hx::fsString,(int)offsetof(FlxAtlas_obj,name),HX_HCSTRING("name","\x4b","\x72","\xff","\x48")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(FlxAtlas_obj,nodes),HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxAtlas_obj,bitmapData),HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33")},
	{hx::fsObject /*::flixel::graphics::FlxGraphic*/ ,(int)offsetof(FlxAtlas_obj,graphic),HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,persist),HX_HCSTRING("persist","\x14","\x22","\x71","\x83")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,border),HX_HCSTRING("border","\xec","\x4c","\x1a","\x64")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,width),HX_HCSTRING("width","\x06","\xb6","\x62","\xca")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,height),HX_HCSTRING("height","\xe7","\x07","\x4c","\x02")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,minWidth),HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,minHeight),HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,maxWidth),HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,maxHeight),HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,allowRotation),HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,powerOfTwo),HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea")},
	{hx::fsObject /*::flixel::graphics::FlxGraphic*/ ,(int)offsetof(FlxAtlas_obj,_graphic),HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(FlxAtlas_obj,_tempStorage),HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo FlxAtlas_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxAtlas_obj::point,HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6")},
	{hx::fsObject /*::openfl::_legacy::geom::Matrix*/ ,(void *) &FlxAtlas_obj::matrix,HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(void *) &FlxAtlas_obj::defaultMinSize,HX_HCSTRING("defaultMinSize","\xb2","\x68","\x9d","\x6c")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(void *) &FlxAtlas_obj::defaultMaxSize,HX_HCSTRING("defaultMaxSize","\xc4","\x52","\xc4","\xfb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxAtlas_obj_sMemberFields[] = {
	HX_HCSTRING("root","\x22","\xee","\xae","\x4b"),
	HX_HCSTRING("name","\x4b","\x72","\xff","\x48"),
	HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f"),
	HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33"),
	HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"),
	HX_HCSTRING("persist","\x14","\x22","\x71","\x83"),
	HX_HCSTRING("border","\xec","\x4c","\x1a","\x64"),
	HX_HCSTRING("width","\x06","\xb6","\x62","\xca"),
	HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"),
	HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1"),
	HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b"),
	HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74"),
	HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31"),
	HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9"),
	HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea"),
	HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad"),
	HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91"),
	HX_HCSTRING("initRoot","\x52","\x1d","\x66","\x50"),
	HX_HCSTRING("addNode","\xc3","\x4c","\x47","\x85"),
	HX_HCSTRING("wrapRoot","\x0c","\x01","\x09","\x97"),
	HX_HCSTRING("tryInsert","\xd4","\x3e","\xf1","\x87"),
	HX_HCSTRING("needToDivideHorizontally","\x5b","\x7d","\xcf","\xa2"),
	HX_HCSTRING("divideNode","\x1b","\x16","\xb5","\x64"),
	HX_HCSTRING("insertFirstNodeInRoot","\x60","\x9d","\x55","\x94"),
	HX_HCSTRING("expand","\x5a","\xee","\x72","\xc4"),
	HX_HCSTRING("expandRoot","\x9c","\x3d","\x1a","\x4c"),
	HX_HCSTRING("expandBitmapData","\xb3","\xdc","\x4b","\xc7"),
	HX_HCSTRING("getNextPowerOfTwo","\x79","\xc4","\xc2","\xb5"),
	HX_HCSTRING("addNodeWithSpacesAndBorders","\xc6","\x41","\x7e","\xb4"),
	HX_HCSTRING("getAtlasFrames","\x5b","\x4e","\xd7","\xb6"),
	HX_HCSTRING("addNodeToAtlasFrames","\xd3","\xfe","\xb4","\xb1"),
	HX_HCSTRING("hasNodeWithName","\x0d","\x52","\xd4","\xd3"),
	HX_HCSTRING("getNode","\xb8","\xb9","\x8c","\x1b"),
	HX_HCSTRING("addNodes","\x50","\xde","\x1b","\x19"),
	HX_HCSTRING("addFromAtlasObjects","\x94","\x9b","\x21","\x50"),
	HX_HCSTRING("bitmapSorter","\x9a","\x34","\x57","\x3b"),
	HX_HCSTRING("createQueue","\xf5","\xc4","\x65","\x87"),
	HX_HCSTRING("addToQueue","\xf5","\x05","\xf9","\x91"),
	HX_HCSTRING("generateFromQueue","\xd2","\xe9","\x4a","\x08"),
	HX_HCSTRING("onClear","\xee","\x0f","\x99","\xde"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("getLibGdxData","\xf6","\xd2","\xa6","\xaf"),
	HX_HCSTRING("deleteSubtree","\xf3","\x95","\xb7","\x8e"),
	HX_HCSTRING("findNodeToInsert","\x0f","\x91","\xf6","\x3b"),
	HX_HCSTRING("set_bitmapData","\x76","\x26","\xd6","\xc9"),
	HX_HCSTRING("get_graphic","\xbf","\xba","\x01","\xfa"),
	HX_HCSTRING("set_persist","\x37","\x89","\xd8","\x13"),
	HX_HCSTRING("set_minWidth","\x91","\xfa","\xac","\x8b"),
	HX_HCSTRING("set_minHeight","\xfc","\xbc","\xfd","\x61"),
	HX_HCSTRING("get_width","\x5d","\x12","\x0c","\x0e"),
	HX_HCSTRING("set_width","\x69","\xfe","\x5c","\xf1"),
	HX_HCSTRING("get_height","\xb0","\x77","\xd3","\xf2"),
	HX_HCSTRING("set_height","\x24","\x16","\x51","\xf6"),
	HX_HCSTRING("set_maxWidth","\x3f","\xe0","\x92","\x3e"),
	HX_HCSTRING("set_maxHeight","\x8e","\xcf","\x40","\x38"),
	HX_HCSTRING("set_powerOfTwo","\x2d","\x2f","\xc4","\x80"),
	::String(null()) };

static void FlxAtlas_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::point,"point");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::matrix,"matrix");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::defaultMinSize,"defaultMinSize");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::defaultMaxSize,"defaultMaxSize");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxAtlas_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::point,"point");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::matrix,"matrix");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::defaultMinSize,"defaultMinSize");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::defaultMaxSize,"defaultMaxSize");
};

#endif

hx::Class FlxAtlas_obj::__mClass;

static ::String FlxAtlas_obj_sStaticFields[] = {
	HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6"),
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("defaultMinSize","\xb2","\x68","\x9d","\x6c"),
	HX_HCSTRING("defaultMaxSize","\xc4","\x52","\xc4","\xfb"),
	::String(null())
};

void FlxAtlas_obj::__register()
{
	hx::Object *dummy = new FlxAtlas_obj;
	FlxAtlas_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.graphics.atlas.FlxAtlas","\x4d","\x7b","\x60","\x52");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxAtlas_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxAtlas_obj::__SetStatic;
	__mClass->mMarkFunc = FlxAtlas_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxAtlas_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxAtlas_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxAtlas_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxAtlas_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxAtlas_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxAtlas_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxAtlas_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_27_boot)
HXDLIN(  27)		point =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_28_boot)
HXDLIN(  28)		matrix =  ::openfl::_legacy::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_33_boot)
HXDLIN(  33)		defaultMinSize =  ::flixel::math::FlxPoint_obj::__alloc( HX_CTX ,(int)128,(int)128);
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_f38becfab6571882_38_boot)
HXDLIN(  38)		defaultMaxSize =  ::flixel::math::FlxPoint_obj::__alloc( HX_CTX ,(int)1024,(int)1024);
            	}
}

} // end namespace flixel
} // end namespace graphics
} // end namespace atlas
